<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Synan: /common/utilit.h</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>/common/utilit.h</h1><div class="fragment"><pre class="fragment"><span class="comment">// ==========  This file is under  LGPL, the GNU Lesser General Public Licence</span>
<span class="comment">// ==========  Dialing Syntax Analysis (www.aot.ru)</span>
<span class="comment">// ==========  Copyright by Alexey Sokirko</span>

<span class="preprocessor">#ifndef utilit_h</span>
<span class="preprocessor"></span><span class="preprocessor"> #define utilit_h</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include  &lt;stdio.h&gt;</span>




<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>
        <span class="comment">// it is used to find memory leaks</span>
<span class="preprocessor">        #ifdef DETECT_MEMORY_LEAK</span>
<span class="preprocessor"></span>                <span class="keyword">extern</span> <span class="keywordtype">void</span>* operator new(size_t nSize, <span class="keyword">const</span> <span class="keywordtype">char</span>* lpszFileName, <span class="keywordtype">int</span> nLine);
                <span class="keyword">extern</span> <span class="keywordtype">void</span>  operator delete(<span class="keywordtype">void</span>* p, <span class="keyword">const</span> <span class="keywordtype">char</span>* lpszFileName, <span class="keywordtype">int</span> nLine);
<span class="preprocessor">                #define DEBUG_NEW new(THIS_FILE, __LINE__)</span>
<span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        

<span class="preprocessor">        #include "windows.h"</span>
<span class="preprocessor">        #include "winuser.h"</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include  &lt;assert.h&gt;</span>
<span class="preprocessor">#include  &lt;stdio.h&gt;</span>
<span class="preprocessor">#include  &lt;stdarg.h&gt;</span>

<span class="preprocessor">#include  &lt;ctype.h&gt;</span>
<span class="preprocessor">#include  &lt;string&gt;</span>
<span class="preprocessor">#include  &lt;algorithm&gt;</span>
<span class="preprocessor">#include  &lt;stdexcept&gt;</span>
<span class="preprocessor">#include  &lt;vector&gt;</span>
<span class="preprocessor">#include  "set"</span>
<span class="preprocessor">#include  "stack"</span>
<span class="preprocessor">#include  "map"</span>
<span class="preprocessor">#include "time.h"</span>


<span class="preprocessor">#pragma warning (disable : 4018)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning (disable : 4244)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning (disable : 4103)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning  (disable : 4530)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning  (disable : 4251)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning  (disable : 4996)</span>
<span class="preprocessor"></span>                

<span class="preprocessor">#ifdef STLPORT</span>
<span class="preprocessor"></span>        <span class="keyword">using</span> <span class="keyword">namespace </span>stlport;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keyword">using</span> <span class="keyword">namespace </span>std;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>




<span class="comment">//#if !defined (STLPORT) || defined(__STL_USE_NAMESPACES)</span>
<span class="comment">//using namespace std;</span>
<span class="comment">//#endif</span>



<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> BYTE;

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #include  &lt;io.h&gt;</span>
<span class="preprocessor">        #include &lt;fcntl.h&gt;</span>
        <span class="keyword">typedef</span> __int64 QWORD;
        
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #include  &lt;unistd.h&gt;</span>
        <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    DWORD;  
        <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  WORD;
        <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>               QWORD;
        <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    UINT;
        <span class="keyword">const</span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _MAX_PATH = 512;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> vector&lt;string&gt; StringVector;
<span class="keyword">typedef</span> set&lt;string&gt; StringSet;
<span class="keyword">typedef</span> vector&lt;DWORD&gt; DwordVector;

<span class="keyword">inline</span> QWORD GetMaxQWORD ()
{
<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span>  0xffffffffffffffff;
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span>  0xffffffffffffffffULL;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>};

<span class="keyword">const</span> BYTE   cHyphenChar   = (BYTE) <span class="charliteral">'-'</span>;
<span class="keyword">const</span> BYTE   cPeriodChar   = (BYTE) <span class="charliteral">'.'</span>;
<span class="keyword">const</span> BYTE   cEofChar      = (BYTE) 0x1a;
<span class="keyword">const</span> BYTE   cPtrChar      = (BYTE) 0x13;
<span class="keyword">const</span> BYTE   cSpaceChar    = (BYTE) 32;
<span class="keyword">const</span> BYTE   cBackChar     = (BYTE) <span class="charliteral">'€'</span>;
<span class="keyword">const</span> BYTE   cFullChar    = (BYTE) <span class="charliteral">'«'</span>;
<span class="keyword">const</span> BYTE   cNumChar      = (BYTE) <span class="charliteral">'N'</span>;
<span class="keyword">const</span> BYTE   cAmpChar      = (BYTE) <span class="charliteral">'&amp;'</span>;
<span class="keyword">const</span> BYTE   cParagraph    = (BYTE) 21;
<span class="keyword">const</span> BYTE   cCompanyChar  = (BYTE) 176;
<span class="keyword">const</span> BYTE   cIonChar      = (BYTE) 183;
<span class="keyword">const</span> BYTE   cNumberChar   = (BYTE) 0xB9;
<span class="keyword">const</span> BYTE   cPiChar       = (BYTE) 182;
<span class="keyword">const</span> BYTE   cEllipseChar  = (BYTE) 133;

<span class="comment">// morphology&amp;syntax</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> {  morphUnknown = 0, morphRussian = 1, morphEnglish = 2, morphGerman = 3, morphGeneric = 4} MorphLanguageEnum;

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #ifdef _DLL</span>
<span class="preprocessor"></span><span class="preprocessor">                #define USE_FSEEK32 // in future versions of MS VC it shoold be deleted</span>
<span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">//#define USE_FSEEK32</span>
<span class="preprocessor">#ifdef USE_FSEEK32</span>
<span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">int</span> file_off_t;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keyword">typedef</span> QWORD file_off_t;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">class </span>CExpc
{
 <span class="keyword">public</span>:
        string  m_strCause;
        <span class="keywordtype">int</span>             m_ErrorCode;

        CExpc(<span class="keyword">const</span> string&amp; Cause, <span class="keywordtype">int</span> ErrorCode = -1);
        CExpc(<span class="keyword">const</span> CExpc&amp; from);
        CExpc&amp; operator= (<span class="keyword">const</span> CExpc&amp; from);
};


<span class="comment">// working with files</span>
<span class="keyword">extern</span> <span class="keywordtype">bool</span>                     FileExists (<span class="keyword">const</span> <span class="keywordtype">char</span> *FName);
<span class="keyword">extern</span> file_off_t       FileSize (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>                     FSeek(FILE* fp, file_off_t pos, <span class="keywordtype">int</span> origin);
<span class="keyword">extern</span> file_off_t       FTell(FILE* fp);



<span class="keyword">extern</span> <span class="keywordtype">void</span>             ErrorMessage (<span class="keyword">const</span> string&amp; Titul, <span class="keyword">const</span> string&amp; Message);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             ErrorMessage (<span class="keyword">const</span> string&amp; Message);
<span class="keyword">extern</span> string   MakeFName ( <span class="keyword">const</span> string&amp; InpitFileName,  <span class="keyword">const</span> string&amp; Ext);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             MakePath (<span class="keywordtype">char</span>* RossPath, <span class="keywordtype">char</span>* FileName, <span class="keywordtype">char</span>* FullPath);
<span class="keyword">extern</span> string   GetPathByFile (string FileName);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             IsBinFile (<span class="keyword">const</span> <span class="keywordtype">char</span>* FileName);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             IsEmptyLine ( <span class="keyword">const</span> <span class="keywordtype">char</span> *t);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             IsHtmlFile (<span class="keyword">const</span> string&amp; FileName);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             AddFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* MainFile, <span class="keyword">const</span> <span class="keywordtype">char</span>* ToAdd);
<span class="keyword">extern</span> string   CreateTempFileName();
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             MakeDir(<span class="keyword">const</span> string&amp; txt);


<span class="comment">// working with registry </span>
<span class="keyword">extern</span> string   GetRegistryString (string RegistryPath);
<span class="keyword">extern</span> string   GetRegistryStringFromLocalIniFile (string RegistryPath);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             CanGetRegistryString (string RegistryPath);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             SetRegistryString (string RegistryPath, string Value);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             IsRmlRegistered(string&amp; Error);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             CheckEvaluationTime();
<span class="keyword">extern</span> <span class="keyword">struct </span>tm  RmlGetCurrentTime ();
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             ReadTimeOutFromRegistry(<span class="keywordtype">bool</span> bReadFromLocalFile, <span class="keywordtype">int</span>&amp; TimeOut);
<span class="keyword">extern</span> string   GetIniFilePath();

<span class="comment">// working with strings</span>
<span class="keyword">extern</span> <span class="keywordtype">char</span>*    rtrim (<span class="keywordtype">char</span>* s);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             IsSuperEqualChar (BYTE ch1, BYTE ch2, MorphLanguageEnum langua);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             strscmp ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t l, MorphLanguageEnum langua);
<span class="keyword">extern</span> <span class="keywordtype">int</span>              CompareWithoutRegister ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t l, MorphLanguageEnum langua);
<span class="keyword">extern</span> BYTE             force_rus_char (BYTE ch);
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             force_to_rus (<span class="keywordtype">char</span>* dest, <span class="keyword">const</span> <span class="keywordtype">char</span>* sour, size_t len);
<span class="keyword">extern</span> <span class="keywordtype">char</span>*    IntToStr (<span class="keywordtype">int</span> Value, <span class="keywordtype">char</span>* Buffer);
<span class="keyword">extern</span> string&amp;  IntToStr (<span class="keywordtype">int</span> Value, string&amp; oBuffer);
<span class="keyword">extern</span> string   Format( <span class="keyword">const</span> <span class="keywordtype">char</span>* format, ... );
<span class="keyword">extern</span> string&amp;  TrimLeft (string&amp; str);
<span class="keyword">extern</span> string&amp;  TrimRight (string&amp; str);
<span class="keyword">extern</span> string&amp;  Trim (string&amp; str);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             rml_TRACE( <span class="keyword">const</span> <span class="keywordtype">char</span>* format, ... );
<span class="keyword">extern</span> <span class="keywordtype">bool</span>             LoadFileToString(string FileName, string&amp; Result);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             SqueezeSpacesAndDeleteEoln(string&amp; s);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             KOI8ToWin (string&amp; s);
<span class="keyword">extern</span> <span class="keywordtype">void</span>             WinToKOI8 (string&amp; s);
<span class="keyword">extern</span> DWORD    StringCrc32(<span class="keyword">const</span> <span class="keywordtype">char</span>* szString);



<span class="keyword">extern</span> <span class="keywordtype">void</span> QPEncodeString(string&amp; s);
<span class="keyword">extern</span> <span class="keywordtype">void</span> QPDecodeString(string&amp; s);
<span class="preprocessor">#ifndef WIN32</span>
<span class="preprocessor"></span>        <span class="keyword">extern</span> <span class="keywordtype">void</span> strrev(<span class="keywordtype">char</span>* s);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">const</span> BYTE      UnknownPartOfSpeech             = 0xff;
<span class="keyword">const</span> <span class="keywordtype">int</span>       UnknownSyntaxElement = 0xffff;
<span class="keyword">typedef</span> <span class="keyword">enum</span> {DontKillHomonyms = 0, CoverageKillHomonyms = 1} KillHomonymsEnum;

<span class="keyword">typedef</span> <span class="keyword">enum</span> { LocThes = 0, FinThes, CompThes, OmniThes, NoneThes } EThesType;
<span class="keyword">typedef</span> <span class="keyword">enum</span> { EClause = 0, EWord, EGroup, ENoneType } EUnitType;


<span class="keyword">extern</span> <span class="keywordtype">int</span> GetPredictionPartOfSpeech(<span class="keyword">const</span> string&amp; PartOfSpeech, MorphLanguageEnum langua);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> GetLanguageByString (string s, MorphLanguageEnum&amp; Result);
<span class="keyword">extern</span> string GetStringByLanguage (MorphLanguageEnum Langua);



<span class="comment">// ==============   Saving and restoring vectors  ======================</span>

<span class="comment">// ============== DWORD =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> DWORD&amp; t)
{
        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(DWORD);
};
<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> DWORD&amp; i, BYTE* buf)
{
        *((DWORD*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
}

<span class="keyword">inline</span> size_t restore_from_bytes(DWORD&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((DWORD*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};



<span class="comment">// ============== int =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; t)
{
        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(int);
};
<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i, BYTE* buf)
{
        *((<span class="keywordtype">int</span>*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
}

<span class="keyword">inline</span> size_t restore_from_bytes(<span class="keywordtype">int</span>&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((<span class="keywordtype">int</span>*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};


<span class="comment">// ============== CHAR =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> <span class="keywordtype">char</span>&amp; t)
{
        <span class="keywordflow">return</span> 1;
};

<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> <span class="keywordtype">char</span>&amp; i, BYTE* buf)
{
        *((<span class="keywordtype">char</span>*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};

<span class="keyword">inline</span> size_t restore_from_bytes(<span class="keywordtype">char</span>&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((<span class="keywordtype">char</span>*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};


<span class="comment">// ============== BYTE =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> BYTE&amp; t)
{
        <span class="keywordflow">return</span> 1;
};

<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> BYTE&amp; i, BYTE* buf)
{
        *((BYTE*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};

<span class="keyword">inline</span> size_t restore_from_bytes(BYTE&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((BYTE*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};



<span class="comment">// ============== WORD =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> WORD&amp; t)
{
        <span class="keywordflow">return</span> 2;
};

<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> WORD&amp; i, BYTE* buf)
{
        *((WORD*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};

<span class="keyword">inline</span> size_t restore_from_bytes(WORD&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((WORD*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};


<span class="comment">// ============== QWORD =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> QWORD&amp; t)
{
        <span class="keywordflow">return</span> 8;
};

<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> QWORD&amp; i, BYTE* buf)
{
        *((QWORD*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};

<span class="keyword">inline</span> size_t restore_from_bytes(QWORD&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((QWORD*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};

<span class="comment">// ============== DOUBLE =====================</span>
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t)
{
        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(t);
};
<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; i, BYTE* buf)
{
        *((<span class="keywordtype">double</span>*)buf) = i;
        <span class="keywordflow">return</span> get_size_in_bytes(i);
}

<span class="keyword">inline</span> size_t restore_from_bytes(<span class="keywordtype">double</span>&amp; i, <span class="keyword">const</span> BYTE* buf)
{
        i = *((<span class="keywordtype">double</span>*)buf);
        <span class="keywordflow">return</span> get_size_in_bytes(i);
};



<span class="comment">// ============== PAIR =====================</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> pair&lt;T, T&gt;&amp; t)
{
        <span class="keywordflow">return</span> get_size_in_bytes(t.first) * 2;
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> pair&lt;T, T&gt;&amp; t, BYTE* buf)


{
        buf += save_to_bytes(t.first, buf);
        buf += save_to_bytes(t.second, buf);
        <span class="keywordflow">return</span> get_size_in_bytes(t);
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t restore_from_bytes(pair&lt;T, T&gt;&amp; t, <span class="keyword">const</span> BYTE* buf)
{
        buf += restore_from_bytes(t.first, buf);
        buf += restore_from_bytes(t.second, buf);
        <span class="keywordflow">return</span> get_size_in_bytes(t);
};


<span class="comment">// ============== TRIPLE =====================</span>

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<span class="keyword">struct  </span>troika : <span class="keyword">public</span> pair&lt;T1, T2&gt;
{
        T3 third;
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t get_size_in_bytes (<span class="keyword">const</span> troika&lt;T, T, T&gt;&amp; t)
{
        <span class="keywordflow">return</span> get_size_in_bytes(t.first) * 3;
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t save_to_bytes(<span class="keyword">const</span> troika&lt;T, T, T&gt;&amp; t, BYTE* buf)
{
        buf += save_to_bytes(t.first, buf);
        buf += save_to_bytes(t.second, buf);
        buf += save_to_bytes(t.third, buf);
        <span class="keywordflow">return</span> get_size_in_bytes(t);
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> size_t restore_from_bytes(troika&lt;T, T, T&gt;&amp; t, <span class="keyword">const</span> BYTE* buf)
{
        buf += restore_from_bytes(t.first, buf);
        buf += restore_from_bytes(t.second, buf);
        buf += restore_from_bytes(t.third, buf);
        <span class="keywordflow">return</span> get_size_in_bytes(t);
};


<span class="keyword">const</span> <span class="keywordtype">int</span> VectorMaxStructSize = 200;

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keywordtype">void</span> ReadVectorInner (FILE* fp, vector&lt;T&gt;&amp; V, size_t Count)
{
<span class="preprocessor">#ifdef  WIN32</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (_setmode( _fileno( fp ), _O_BINARY ) != _O_BINARY) 
                <span class="keywordflow">throw</span> CExpc(Format(<span class="stringliteral">"ReadVectorInner: File is not opened in binary mode!"</span>));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">try</span>
        {
                T dummy;
                size_t size_of_t = get_size_in_bytes(dummy);

                BYTE buffer[VectorMaxStructSize];
                assert (size_of_t &lt; VectorMaxStructSize);

                V.clear();
                V.reserve(Count);
                <span class="keywordflow">if</span> (V.capacity() &lt; Count) 
                        <span class="keywordflow">throw</span> CExpc(Format(<span class="stringliteral">"cannot allocate %u bytes in ReadVectorInner"</span>,size_of_t*Count));

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Count; i++)
                {
                        <span class="keywordflow">if</span> (fread ((<span class="keywordtype">void</span>*)buffer, size_of_t, 1, fp)!=1)
                                <span class="keywordflow">throw</span> CExpc(Format(<span class="stringliteral">"cannot read %i item in ReadVectorInner"</span>,i));
                        restore_from_bytes (dummy, buffer);
                        V.push_back(dummy);
                };
        }
        <span class="keywordflow">catch</span> ( length_error  &amp;e ) 
        {
                fprintf (stderr, <span class="stringliteral">"ReadVectorInner:length_error exception is caught: %s\n"</span>, e.what( ));
                <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> ( exception &amp;e ) 
        {
                fprintf (stderr, <span class="stringliteral">"ReadVectorInner: general std::exception is caught: %s\n"</span>, e.what( ));
                <span class="keywordflow">throw</span>;
        };

};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> <span class="keywordtype">void</span> ReadVector (<span class="keyword">const</span> string&amp; FileName, vector&lt;T&gt;&amp; V)
{
        V.clear();
        file_off_t sz = FileSize(FileName.c_str());

        FILE* fp = fopen (FileName.c_str(),<span class="stringliteral">"rb"</span>);
        <span class="keywordflow">if</span> (!fp) <span class="keywordflow">return</span>;
        
        T dummy;
        size_t size_of_t = get_size_in_bytes(dummy);
        size_t Count = sz/size_of_t;
        <span class="keywordflow">try</span> {
        ReadVectorInner(fp, V, Count);
                fclose (fp);
                fp = 0;
        }
        <span class="keywordflow">catch</span> (...)
        {
                <span class="keywordflow">if</span> (fp) fclose (fp);
                <span class="keywordflow">throw</span>;
        }
        
};


<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keywordtype">bool</span> WriteVectorInner (FILE* fp, <span class="keyword">const</span> vector&lt;T&gt;&amp; V)
{
<span class="preprocessor">        #ifdef  WIN32</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> (_setmode( _fileno( fp ), _O_BINARY ) != _O_BINARY) 
                {
                        ErrorMessage(<span class="stringliteral">"WriteVectorInner"</span>, <span class="stringliteral">"File is not opened in binary mode!"</span>);
                        <span class="keywordflow">return</span> <span class="keyword">false</span>;
                };
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>
        T dummy;
        size_t size_of_t = get_size_in_bytes(dummy);

        BYTE buffer[VectorMaxStructSize];
        assert (size_of_t &lt; VectorMaxStructSize);

        size_t  count = V.size();

        <span class="keywordflow">for</span> (size_t i =0; i &lt; count; i++)
        {
                save_to_bytes(V[i], buffer);
                <span class="keywordflow">if</span> (!fwrite((<span class="keywordtype">void</span>*)buffer, size_of_t, 1, fp)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};


<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> <span class="keywordtype">bool</span> WriteVector (<span class="keyword">const</span> string&amp; FileName, <span class="keyword">const</span> vector&lt;T&gt;&amp; V)
{
        FILE* fp = fopen (FileName.c_str(),<span class="stringliteral">"wb"</span>);
        <span class="keywordflow">if</span> (!fp)
        {
                ErrorMessage (<span class="stringliteral">"Cannot write vector to "</span>+FileName);
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };
        <span class="keywordtype">bool</span> b = WriteVectorInner(fp, V);
        fclose (fp);
        <span class="keywordflow">return</span> b;
};



<span class="comment">/*</span>
<span class="comment">clears also capacity</span>
<span class="comment">*/</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<span class="keywordtype">void</span> ClearVector(vector&lt;T&gt;&amp; V)
{
        V.clear();
        vector&lt;T&gt; dummy (V);
        V.swap (dummy);
};





<span class="comment">// ============     Brackets =========================</span>


<span class="keyword">extern</span> <span class="keywordtype">int</span> isbracket  (BYTE x);
<span class="keyword">extern</span> <span class="keywordtype">int</span> dual_bracket (BYTE x);



<span class="comment">//==================    Digits   ===========================</span>
<span class="keyword">extern</span> <span class="keywordtype">bool</span> is_upper_roman_digit (BYTE ch);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> is_lower_roman_digit (BYTE ch);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> is_roman_number ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t len);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> is_pseudo_graph(BYTE x);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> is_word_delim (BYTE x);
<span class="comment">//  =============  Punctuation Letters ======================</span>

<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_spc_fill (BYTE x);




<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_english_upper(BYTE x);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_english_lower(BYTE x);

<span class="keyword">const</span> BYTE Auml  = 196; <span class="comment">// "Ä"</span>
<span class="keyword">const</span> BYTE auml  = 228; <span class="comment">// "ä"</span>
<span class="keyword">const</span> BYTE Uuml  = 220; <span class="comment">// "Ü"</span>
<span class="keyword">const</span> BYTE uuml  = 252; <span class="comment">// "ü"</span>
<span class="keyword">const</span> BYTE Ouml  = 214; <span class="comment">// "Ö"</span>
<span class="keyword">const</span> BYTE ouml  = 246; <span class="comment">// "ö"</span>
<span class="keyword">const</span> BYTE szlig  = 223; <span class="comment">//"ß"</span>
<span class="keyword">const</span> BYTE Nu  = 181;   <span class="comment">// "÷"</span>
<span class="keyword">const</span> BYTE agrave  = 224; <span class="comment">//"ð"</span>
<span class="keyword">const</span> BYTE egrave  = 232; <span class="comment">//"ø"</span>
<span class="keyword">const</span> BYTE eacute  = 233; <span class="comment">//"ù"</span>


<span class="keyword">const</span> BYTE LowerJO  = (BYTE)<span class="charliteral">'¸'</span>;
<span class="keyword">const</span> BYTE UpperJO  = (BYTE)<span class="charliteral">'¨'</span>;
<span class="keyword">const</span> BYTE Apostrophe  = 39;



 
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_german_upper(BYTE x); 
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_german_lower(BYTE x);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_russian_upper(BYTE x);     
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_russian_lower(BYTE x);

<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_lower_consonant(BYTE x, MorphLanguageEnum Langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_upper_consonant(BYTE x, MorphLanguageEnum Langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_lower_vowel(BYTE x, MorphLanguageEnum Langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_upper_vowel(BYTE x, MorphLanguageEnum Langua);

<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_english_alpha(BYTE x);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_russian_alpha(BYTE x);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_german_alpha(BYTE x);

<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_alpha (BYTE x);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_alpha (BYTE x, MorphLanguageEnum langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_lower_alpha(BYTE x, MorphLanguageEnum langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> is_upper_alpha(BYTE x, MorphLanguageEnum langua);
<span class="keyword">extern</span>  <span class="keywordtype">bool</span> isnspace(BYTE x);


<span class="comment">// ===============  Register ========================================</span>
<span class="keyword">extern</span>  BYTE etoupper (BYTE ch);
<span class="keyword">extern</span>  BYTE etolower (BYTE ch);
<span class="keyword">extern</span>  BYTE rtoupper (BYTE ch); 
<span class="keyword">extern</span>  BYTE rtolower (BYTE ch); 
<span class="keyword">extern</span>  BYTE gtoupper (BYTE ch); 
<span class="keyword">extern</span>  BYTE gtolower (BYTE ch); 
<span class="keyword">extern</span>  BYTE ReverseChar (BYTE ch, MorphLanguageEnum langua);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* RusMakeUpper (<span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* EngMakeUpper (<span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> string&amp; EngMakeUpper (string&amp; word);
<span class="keyword">extern</span> string&amp; EngMakeLower (string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* GerMakeUpper (<span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> string&amp; GerMakeUpper (string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* RusMakeLower (<span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> string&amp; EngRusMakeLower (string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* EngRusMakeLower (<span class="keywordtype">char</span>* word);
<span class="keyword">extern</span> <span class="keywordtype">char</span>* RmlMakeUpper (<span class="keywordtype">char</span> *word, MorphLanguageEnum langua);
<span class="keyword">extern</span> string&amp; RmlMakeUpper (string&amp; word, MorphLanguageEnum langua);
<span class="keyword">extern</span> string&amp; RmlMakeLower (string&amp; word, MorphLanguageEnum langua);

<span class="comment">// êîíâåðòèðóåò èç ñòðî÷íîé êèðèëëèöû â ïðîïèñíûå </span>
<span class="keyword">extern</span> string&amp;  EngRusMakeUpper (string&amp; word);
<span class="comment">// êîíâåðòèðóåò èç ñòðî÷íîé êèðèëëèöû â ïðîïèñíûå </span>
<span class="keyword">extern</span> <span class="keywordtype">char</span>*  EngRusMakeUpper (<span class="keywordtype">char</span>* word);


<span class="comment">// check languaage </span>
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsRussian (<span class="keyword">const</span> <span class="keywordtype">char</span> *word); 
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsRussian (<span class="keyword">const</span> string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsEnglish (<span class="keyword">const</span> <span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsEnglish (<span class="keyword">const</span> string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsGerman (<span class="keyword">const</span> <span class="keywordtype">char</span> *word);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> IsGerman (<span class="keyword">const</span> string&amp; word);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> CheckLanguage (<span class="keyword">const</span> <span class="keywordtype">char</span> *word, MorphLanguageEnum langua);
<span class="keyword">extern</span> <span class="keywordtype">bool</span> CheckLanguage (<span class="keyword">const</span> string&amp; word, MorphLanguageEnum langua);



<span class="keyword">extern</span> <span class="keywordtype">void</span> ConvertJO2Je(string&amp; src);
<span class="keyword">extern</span> <span class="keywordtype">void</span> ConvertJO2Je(<span class="keywordtype">char</span>* src);
<span class="keyword">extern</span> <span class="keywordtype">void</span> ConvertJO2Je(<span class="keywordtype">char</span>* src, size_t Length);
<span class="keyword">extern</span> string ConvertASCIIToHtmlSymbols(<span class="keyword">const</span> string&amp; txt);


<span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Conv&gt;
T&amp; RegisterConverter (T&amp; word, size_t Len, Pred P,  Conv C)
{
        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; Len; i++ )
        <span class="keywordflow">if</span> ( P( (BYTE)word[i] )  )
                        word[i] = C ( (BYTE)word[i] );

    <span class="keywordflow">return</span> word;
}


<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
T&amp; GerEngRusMakeUpperTemplate (T&amp; word, MorphLanguageEnum Langua, size_t Len )
{
        <span class="keywordflow">if</span> (Len == 0) <span class="keywordflow">return</span> word;

        <span class="keywordflow">if</span> (Langua == morphGerman)
                <span class="keywordflow">return</span> RegisterConverter(word, Len, is_german_lower, gtoupper);
        <span class="keywordflow">else</span>
                <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; Len; i++ )
                        <span class="keywordflow">if</span> (is_russian_lower((BYTE)word[i]))
                                        word[i] = rtoupper ( (BYTE)word[i] );
                        <span class="keywordflow">else</span>
                        <span class="keywordflow">if</span> (is_english_lower((BYTE)word[i]))
                                        word[i] = etoupper ( (BYTE)word[i] );

        <span class="keywordflow">return</span> word;
};      





<span class="comment">//  QWORD mask</span>
<span class="preprocessor">#define _QM(X) (((QWORD)1)&lt;&lt;X)</span>
<span class="preprocessor"></span>
<span class="keyword">enum</span> RegisterEnum {AnyRegister=0, LowLow=1, UpLow=2, UpUp=3};


<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Tue Feb 7 15:38:48 2006 for Synan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
