<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Synan: /common/utilit.cpp</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>/common/utilit.cpp</h1><div class="fragment"><pre class="fragment"><span class="preprocessor">#include "utilit.h"</span>
<span class="preprocessor">#include "util_classes.h"</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>

<span class="comment">//  for mkdir</span>
<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #include &lt;direct.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #include &lt;sys/stat.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef DETECT_MEMORY_LEAK</span>
<span class="preprocessor"></span><span class="preprocessor">        #ifdef _DEBUG</span>
<span class="preprocessor"></span><span class="preprocessor">        #define new DEBUG_NEW</span>
<span class="preprocessor"></span><span class="preprocessor">        #undef THIS_FILE</span>
<span class="preprocessor"></span>        <span class="keyword">static</span> <span class="keywordtype">char</span> THIS_FILE[] = __FILE__;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">const</span> WORD fWordDelim = 1;
<span class="keyword">const</span> WORD RusUpper = 2;
<span class="keyword">const</span> WORD RusLower = 4;
<span class="keyword">const</span> WORD GerUpper = 8;
<span class="keyword">const</span> WORD GerLower = 16;
<span class="keyword">const</span> WORD EngUpper = 32;
<span class="keyword">const</span> WORD EngLower = 64;
<span class="keyword">const</span> WORD OpnBrck = 128;
<span class="keyword">const</span> WORD ClsBrck = 256;
<span class="keyword">const</span> WORD UpRomDigits = 512;
<span class="keyword">const</span> WORD LwRomDigits = 1024;
<span class="keyword">const</span> WORD LatinVowel = 2048;
<span class="keyword">const</span> WORD RussianVowel = 4096;


<span class="keyword">const</span> WORD ASCII[256] = {
<span class="comment">/*null (nul)*/</span>                                     fWordDelim,
<span class="comment">/*start of heading (soh)*/</span>                         fWordDelim,
<span class="comment">/*start of text (stx)*/</span>                            fWordDelim,
<span class="comment">/*end of text (etx)*/</span>                              fWordDelim,
<span class="comment">/*end of transmission (eot)*/</span>                      fWordDelim,
<span class="comment">/*enquiry (enq)*/</span>                                  fWordDelim,
<span class="comment">/*acknowledge (ack)*/</span>                              fWordDelim,
<span class="comment">/*bell (bel)*/</span>                                     fWordDelim,
<span class="comment">/*backspace (bs)*/</span>                                 fWordDelim,
<span class="comment">/*character tabulation (ht)*/</span>                      fWordDelim,
<span class="comment">/*line feed (lf)*/</span>                                 fWordDelim,
<span class="comment">/*line tabulation (vt)*/</span>                           fWordDelim,
<span class="comment">/*form feed (ff)*/</span>                                 fWordDelim,
<span class="comment">/*carriage return (cr)*/</span>                           fWordDelim,
<span class="comment">/*shift out (so)*/</span>                                 fWordDelim,
<span class="comment">/*shift in (si)*/</span>                                  fWordDelim,
<span class="comment">/*datalink escape (dle)*/</span>                          fWordDelim,
<span class="comment">/*device control one (dc1)*/</span>                       fWordDelim,
<span class="comment">/*device control two (dc2)*/</span>                       fWordDelim,
<span class="comment">/*device control three (dc3)*/</span>                     fWordDelim,
<span class="comment">/*device control four (dc4)*/</span>                      fWordDelim,
<span class="comment">/*negative acknowledge (nak)*/</span>                     fWordDelim,
<span class="comment">/*syncronous idle (syn)*/</span>                          fWordDelim,
<span class="comment">/*end of transmission block (etb)*/</span>                fWordDelim,
<span class="comment">/*cancel (can)*/</span>                                   fWordDelim,
<span class="comment">/*end of medium (em)*/</span>                             fWordDelim,
<span class="comment">/*substitute (sub)*/</span>                               fWordDelim,
<span class="comment">/*escape (esc)*/</span>                                   fWordDelim,
<span class="comment">/*file separator (is4)*/</span>                           fWordDelim,
<span class="comment">/*group separator (is3)*/</span>                          fWordDelim,
<span class="comment">/*record separator (is2)*/</span>                         fWordDelim,
<span class="comment">/*unit separator (is1)*/</span>                           fWordDelim,
<span class="comment">/*space ' '*/</span>                                      fWordDelim,
<span class="comment">/*exclamation mark '!'*/</span>                           fWordDelim,
<span class="comment">/*quotation mark '"'*/</span>                             fWordDelim,
<span class="comment">/*number sign '#'*/</span>                                fWordDelim,
<span class="comment">/*dollar sign '$'*/</span>                                fWordDelim,
<span class="comment">/*percent sign '%'*/</span>                               fWordDelim,
<span class="comment">/*ampersand '&amp;'*/</span>                                  fWordDelim,
<span class="comment">/*apostrophe '''*/</span>                                 fWordDelim|RusUpper|RusLower, <span class="comment">// твердый знак в виде апострофа</span>
<span class="comment">/*left parenthesis '('*/</span>                           fWordDelim|OpnBrck,
<span class="comment">/*right parenthesis ')'*/</span>                          fWordDelim|ClsBrck,
<span class="comment">/*asterisk '*'*/</span>                                   fWordDelim,
<span class="comment">/*plus sign '+'*/</span>                                  fWordDelim,
<span class="comment">/*comma ','*/</span>                                      fWordDelim,
<span class="comment">/*hyphen-minus '-'*/</span>                               fWordDelim,
<span class="comment">/*full stop '.'*/</span>                                  fWordDelim,
<span class="comment">/*solidus '/'*/</span>                                    fWordDelim,
<span class="comment">/*digit zero '0'*/</span>                                 0,
<span class="comment">/*digit one '1'*/</span>                                  0,
<span class="comment">/*digit two '2'*/</span>                                  0,
<span class="comment">/*digit three '3'*/</span>                                0,
<span class="comment">/*digit four '4'*/</span>                                 0,
<span class="comment">/*digit five '5'*/</span>                                 0,
<span class="comment">/*digit six '6'*/</span>                                  0,
<span class="comment">/*digit seven '7'*/</span>                                0,
<span class="comment">/*digit eight '8'*/</span>                                0,
<span class="comment">/*digit nine '9'*/</span>                                 0,
<span class="comment">/*colon ':'*/</span>                                      fWordDelim,
<span class="comment">/*semicolon ';'*/</span>                                  fWordDelim,
<span class="comment">/*less-than sign '&lt;'*/</span>                             fWordDelim|OpnBrck,
<span class="comment">/*equals sign '='*/</span>                                fWordDelim,
<span class="comment">/*greater-than sign '&gt;'*/</span>                          fWordDelim|ClsBrck,
<span class="comment">/*question mark '?'*/</span>                              fWordDelim,
<span class="comment">/*commercial at '@'*/</span>                              fWordDelim,
<span class="comment">/*latin capital letter a 'A'*/</span>                     GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter b 'B'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter c 'C'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter d 'D'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter e 'E'*/</span>                     GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter f 'F'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter g 'G'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter h 'H'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter i 'I'*/</span>                     GerUpper|EngUpper|UpRomDigits|LatinVowel,
<span class="comment">/*latin capital letter j 'J'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter k 'K'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter l 'L'*/</span>                     GerUpper|EngUpper|UpRomDigits,
<span class="comment">/*latin capital letter m 'M'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter n 'N'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter o 'O'*/</span>                     GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter p 'P'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter q 'Q'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter r 'R'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter s 'S'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter t 'T'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter u 'U'*/</span>                     GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter v 'V'*/</span>                     GerUpper|EngUpper|UpRomDigits,
<span class="comment">/*latin capital letter w 'W'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter x 'X'*/</span>                     GerUpper|EngUpper|UpRomDigits,
<span class="comment">/*latin capital letter y 'Y'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*latin capital letter z 'Z'*/</span>                     GerUpper|EngUpper,
<span class="comment">/*left square bracket '['*/</span>                        fWordDelim|OpnBrck,
<span class="comment">/*reverse solidus '\'*/</span>                            fWordDelim,
<span class="comment">/*right square bracket ']'*/</span>                       fWordDelim|ClsBrck,
<span class="comment">/*circumflex accent '^'*/</span>                          fWordDelim,
<span class="comment">/*low line '_'*/</span>                                   fWordDelim,
<span class="comment">/*grave accent '`'*/</span>                               fWordDelim,
<span class="comment">/*latin small letter a 'a'*/</span>                       GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter b 'b'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter c 'c'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter d 'd'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter e 'e'*/</span>                       GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter f 'f'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter g 'g'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter h 'h'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter i 'i'*/</span>                       GerLower|EngLower|LwRomDigits|LatinVowel,
<span class="comment">/*latin small letter j 'j'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter k 'k'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter l 'l'*/</span>                       GerLower|EngLower|LwRomDigits,
<span class="comment">/*latin small letter m 'm'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter n 'n'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter o 'o'*/</span>                       GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter p 'p'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter q 'q'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter r 'r'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter s 's'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter t 't'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter u 'u'*/</span>                       GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter v 'v'*/</span>                       GerLower|EngLower|LwRomDigits,
<span class="comment">/*latin small letter w 'w'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter x 'x'*/</span>                       GerLower|EngLower|LwRomDigits,
<span class="comment">/*latin small letter y 'y'*/</span>                       GerLower|EngLower,
<span class="comment">/*latin small letter z 'z'*/</span>                       GerLower|EngLower,
<span class="comment">/*left curly bracket '{'*/</span>                         fWordDelim|OpnBrck,
<span class="comment">/*vertical line '|'*/</span>                              fWordDelim,
<span class="comment">/*right curly bracket '}'*/</span>                        fWordDelim|ClsBrck,
<span class="comment">/*tilde '~'*/</span>                                      fWordDelim,
<span class="comment">/*delete ''*/</span>                                     0,
<span class="comment">/*padding character (pad) '_'*/</span>                    fWordDelim,
<span class="comment">/*high octet preset (hop) '_'*/</span>                    0,
<span class="comment">/*break permitted here (bph) '''*/</span>                 0,
<span class="comment">/*no break here (nbh) '_'*/</span>                        fWordDelim,
<span class="comment">/*index (ind) '"'*/</span>                                0,
<span class="comment">/*next line (nel) ':'*/</span>                            fWordDelim,
<span class="comment">/*start of selected area (ssa) '+'*/</span>               fWordDelim,
<span class="comment">/*end of selected area (esa) '+'*/</span>                 fWordDelim,
<span class="comment">/*character tabulation set (hts) '_'*/</span>             fWordDelim,
<span class="comment">/*character tabulation with justification (htj) '%'*/</span> fWordDelim,
<span class="comment">/*line tabulation set (vts) '_'*/</span>                  0,
<span class="comment">/*partial line forward (pld) '&lt;'*/</span>                 fWordDelim,
<span class="comment">/*partial line backward (plu) '_'*/</span>                fWordDelim,
<span class="comment">/*reverse line feed (ri) '_'*/</span>                     fWordDelim,
<span class="comment">/*single-shift two (ss2) '_'*/</span>                     fWordDelim,
<span class="comment">/*single-shift three (ss3) '_'*/</span>                   fWordDelim,
<span class="comment">/*device control string (dcs) '_'*/</span>                fWordDelim,
<span class="comment">/*private use one (pu1) '''*/</span>                      fWordDelim,
<span class="comment">/*private use two (pu2) '''*/</span>                      fWordDelim,
<span class="comment">/*set transmit state (sts) '"'*/</span>                   fWordDelim,
<span class="comment">/*cancel character (cch) '"'*/</span>                     fWordDelim,
<span class="comment">/*message waiting (mw) ''*/</span>                       fWordDelim,
<span class="comment">/*start of guarded area (spa) '-'*/</span>                fWordDelim,
<span class="comment">/*end of guarded area (epa) '-'*/</span>                  fWordDelim,
<span class="comment">/*start of string (sos) '_'*/</span>                      fWordDelim,
<span class="comment">/*single graphic character introducer (sgci) 'T'*/</span> fWordDelim,
<span class="comment">/*single character introducer (sci) '_'*/</span>          fWordDelim,
<span class="comment">/*control sequence introducer (csi) '&gt;'*/</span>          fWordDelim,
<span class="comment">/*string terminator (st) '_'*/</span>                     fWordDelim,
<span class="comment">/*operating system command (osc) '_'*/</span>             fWordDelim,
<span class="comment">/*privacy message (pm) '_'*/</span>                       fWordDelim,
<span class="comment">/*application program command (apc) '_'*/</span>          fWordDelim,
<span class="comment">/*no-break space ' '*/</span>                             fWordDelim,
<span class="comment">/*inverted exclamation mark 'Ў'*/</span>                  fWordDelim,
<span class="comment">/*cent sign 'ў'*/</span>                                  fWordDelim,
<span class="comment">/*pound sign '_'*/</span>                                 fWordDelim,
<span class="comment">/*currency sign '¤'*/</span>                              fWordDelim,
<span class="comment">/*yen sign '_'*/</span>                                   fWordDelim,
<span class="comment">/*broken bar '¦'*/</span>                                 fWordDelim,
<span class="comment">/*section sign '§'*/</span>                               fWordDelim,
<span class="comment">/*diaeresis 'Ё'*/</span>                                  fWordDelim|RusUpper|RussianVowel,
<span class="comment">/*copyright sign 'c'*/</span>                             fWordDelim,
<span class="comment">/*feminine ordinal indicator 'Є'*/</span>                 fWordDelim,
<span class="comment">/*left pointing double angle quotation mark '&lt;'*/</span>  fWordDelim,
<span class="comment">/*not sign '¬'*/</span>                                   fWordDelim,
<span class="comment">/*soft hyphen '-'*/</span>                                fWordDelim,
<span class="comment">/*registered sign 'R'*/</span>                            fWordDelim,
<span class="comment">/*macron 'Ї'*/</span>                                     fWordDelim,
<span class="comment">/*degree sign '°'*/</span>                                fWordDelim,
<span class="comment">/*plus-minus sign '+'*/</span>                            fWordDelim,
<span class="comment">/*superscript two '_'*/</span>                            fWordDelim,
<span class="comment">/*superscript three '_'*/</span>                          fWordDelim,
<span class="comment">/*acute '_'*/</span>                                      fWordDelim,
<span class="comment">/*micro sign 'ч'*/</span>                                 fWordDelim|GerLower|GerUpper,
<span class="comment">/*pilcrow sign '¶'*/</span>                               fWordDelim,
<span class="comment">/*middle dot '·'*/</span>                                 fWordDelim,
<span class="comment">/*cedilla 'ё'*/</span>                                    RusLower|RussianVowel,
<span class="comment">/*superscript one '№'*/</span>                            fWordDelim,
<span class="comment">/*masculine ordinal indicator 'є'*/</span>                fWordDelim,
<span class="comment">/*right pointing double angle quotation mark '&gt;'*/</span> fWordDelim,
<span class="comment">/*vulgar fraction one quarter '_'*/</span>                fWordDelim,
<span class="comment">/*vulgar fraction one half '_'*/</span>                   fWordDelim,
<span class="comment">/*vulgar fraction three quarters '_'*/</span>             fWordDelim,
<span class="comment">/*inverted question mark 'ї'*/</span>                     fWordDelim,
<span class="comment">/*latin capital letter a with grave 'А'*/</span>          RusUpper|RussianVowel,
<span class="comment">/*latin capital letter a with acute 'Б'*/</span>          RusUpper,
<span class="comment">/*latin capital letter a with circumflex 'В'*/</span>     RusUpper|GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter a with tilde 'Г'*/</span>          RusUpper,
<span class="comment">/*latin capital letter a with diaeresis 'Д'*/</span>      RusUpper|GerUpper|LatinVowel,
<span class="comment">/*latin capital letter a with ring above 'Е'*/</span>     RusUpper|RussianVowel,
<span class="comment">/*latin capital ligature ae 'Ж'*/</span>                  RusUpper,
<span class="comment">/*latin capital letter c with cedilla 'З'*/</span>        RusUpper|GerUpper|EngUpper,
<span class="comment">/*latin capital letter e with grave 'И'*/</span>          RusUpper|GerUpper|EngUpper|LatinVowel|RussianVowel,
<span class="comment">/*latin capital letter e with acute 'Й'*/</span>          RusUpper|GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter e with circumflex 'К'*/</span>     RusUpper|GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter e with diaeresis 'Л'*/</span>      RusUpper,
<span class="comment">/*latin capital letter i with grave 'М'*/</span>          RusUpper,
<span class="comment">/*latin capital letter i with acute 'Н'*/</span>          RusUpper,
<span class="comment">/*latin capital letter i with circumflex 'О'*/</span>     RusUpper|RussianVowel,
<span class="comment">/*latin capital letter i with diaeresis 'П'*/</span>      RusUpper,
<span class="comment">/*latin capital letter eth (icelandic) 'Р'*/</span>       RusUpper,
<span class="comment">/*latin capital letter n with tilde 'С'*/</span>          RusUpper|GerUpper|EngUpper,
<span class="comment">/*latin capital letter o with grave 'Т'*/</span>          RusUpper,
<span class="comment">/*latin capital letter o with acute 'У'*/</span>          RusUpper|RussianVowel,
<span class="comment">/*latin capital letter o with circumflex 'Ф'*/</span>     RusUpper|GerUpper|EngUpper|LatinVowel,
<span class="comment">/*latin capital letter o with tilde 'Х'*/</span>          RusUpper,
<span class="comment">/*latin capital letter o with diaeresis 'Ц'*/</span>      RusUpper|GerUpper|EngUpper|LatinVowel,
<span class="comment">/*multiplication sign 'Ч'*/</span>                        RusUpper,
<span class="comment">/*latin capital letter o with stroke 'Ш'*/</span>         RusUpper|UpRomDigits,
<span class="comment">/*latin capital letter u with grave 'Щ'*/</span>          RusUpper,
<span class="comment">/*latin capital letter u with acute 'Ъ'*/</span>          RusUpper,
<span class="comment">/*latin capital letter u with circumflex 'Ы'*/</span>     RusUpper|GerUpper|EngUpper|LatinVowel|RussianVowel,
<span class="comment">/*latin capital letter u with diaeresis 'Ь'*/</span>      RusUpper|GerUpper|LatinVowel,
<span class="comment">/*latin capital letter y with acute 'Э'*/</span>          RusUpper|RussianVowel,
<span class="comment">/*latin capital letter thorn (icelandic) 'Ю'*/</span>     RusUpper|RussianVowel,
<span class="comment">/*latin small letter sharp s (german) 'Я'*/</span>        RusUpper|GerLower|GerUpper|RussianVowel,
<span class="comment">/*latin small letter a with grave 'а'*/</span>            RusLower|RussianVowel,
<span class="comment">/*latin small letter a with acute 'б'*/</span>            RusLower,
<span class="comment">/*latin small letter a with circumflex 'в'*/</span>       RusLower|GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter a with tilde 'г'*/</span>            RusLower,
<span class="comment">/*latin small letter a with diaeresis 'д'*/</span>        RusLower|GerLower|LatinVowel,
<span class="comment">/*latin small letter a with ring above 'е'*/</span>       RusLower|RussianVowel,
<span class="comment">/*latin small ligature ae 'ж'*/</span>                    RusLower,
<span class="comment">/*latin small letter c with cedilla 'з'*/</span>          RusLower|GerLower|EngLower,
<span class="comment">/*latin small letter e with grave 'и'*/</span>            RusLower|GerLower|EngLower|LatinVowel|RussianVowel,
<span class="comment">/*latin small letter e with acute 'й'*/</span>            RusLower|GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter e with circumflex 'к'*/</span>       RusLower|GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter e with diaeresis 'л'*/</span>        RusLower,
<span class="comment">/*latin small letter i with grave 'м'*/</span>            RusLower,
<span class="comment">/*latin small letter i with acute 'н'*/</span>            RusLower,
<span class="comment">/*latin small letter i with circumflex 'о'*/</span>       RusLower|RussianVowel,
<span class="comment">/*latin small letter i with diaeresis 'п'*/</span>        RusLower,
<span class="comment">/*latin small letter eth (icelandic) 'р'*/</span>         RusLower,
<span class="comment">/*latin small letter n with tilde 'с'*/</span>            RusLower|GerLower|EngLower,
<span class="comment">/*latin small letter o with grave 'т'*/</span>            RusLower,
<span class="comment">/*latin small letter o with acute 'у'*/</span>            RusLower|RussianVowel,
<span class="comment">/*latin small letter o with circumflex 'ф'*/</span>       RusLower|GerLower|EngLower|LatinVowel,
<span class="comment">/*latin small letter o with tilde 'х'*/</span>            RusLower,
<span class="comment">/*latin small letter o with diaeresis 'ц'*/</span>        RusLower|GerLower|EngLower|LatinVowel,
<span class="comment">/*division sign 'ч'*/</span>                              RusLower,
<span class="comment">/*latin small letter o with stroke 'ш'*/</span>           RusLower,
<span class="comment">/*latin small letter u with grave 'щ'*/</span>            RusLower,
<span class="comment">/*latin small letter u with acute 'ъ'*/</span>            RusLower,
<span class="comment">/*latin small letter u with circumflex 'ы'*/</span>       RusLower|GerLower|EngLower|LatinVowel|RussianVowel,
<span class="comment">/*latin small letter u with diaeresis 'ь'*/</span>        RusLower|GerLower|LatinVowel,
<span class="comment">/*latin small letter y with acute 'э'*/</span>            RusLower|RussianVowel,
<span class="comment">/*latin small letter thorn (icelandic) 'ю'*/</span>       RusLower|RussianVowel,
<span class="comment">/*latin small letter y with diaeresis  'я'*/</span>       RusLower|RussianVowel
};


<span class="keywordtype">bool</span> FileExists (<span class="keyword">const</span> <span class="keywordtype">char</span> *FName)
{
        <span class="keywordflow">return</span> (access(FName, 0) == 0);
}

file_off_t FileSize (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
{
        FILE * fp = fopen (filename,<span class="stringliteral">"rb"</span>);
        <span class="keywordflow">if</span> (fp == NULL) <span class="keywordflow">return</span> 0;
        <span class="keywordflow">if</span> (!FSeek(fp, 0,  SEEK_END)) <span class="keywordflow">throw</span> CExpc (Format(<span class="stringliteral">"Cannot move to the begining of the file: %s"</span>, filename));;

        file_off_t size = FTell (fp);
        fclose (fp);
        <span class="keywordflow">return</span> size;
}

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>        <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <span class="keywordtype">int</span> __cdecl _fseeki64(FILE *, __int64, <span class="keywordtype">int</span>);
        <span class="keyword">extern</span> <span class="stringliteral">"C"</span> __int64 __cdecl _ftelli64(FILE *);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">bool</span> FSeek(FILE* fp, file_off_t pos, <span class="keywordtype">int</span> origin)
{
        
<span class="preprocessor">        #ifdef USE_FSEEK32</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span> fseek(fp, pos, origin) == 0;
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span><span class="preprocessor">                #ifdef WIN32</span>
<span class="preprocessor"></span>                        <span class="keywordflow">return</span> _fseeki64(fp, pos, origin) == 0;
<span class="preprocessor">                #else</span>
<span class="preprocessor"></span>                        <span class="keywordflow">return</span> fseeko(fp, pos, origin) == 0;
<span class="preprocessor">                #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>}

file_off_t FTell(FILE* fp)
{
<span class="preprocessor">        #ifdef USE_FSEEK32</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span> ftell(fp);
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span><span class="preprocessor">                #ifdef WIN32</span>
<span class="preprocessor"></span>                        <span class="keywordflow">return</span> _ftelli64(fp) ;
<span class="preprocessor">                #else</span>
<span class="preprocessor"></span>                        <span class="keywordflow">return</span> ftello(fp);
<span class="preprocessor">                #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>}


void(*GlobalErrorMessage)(<span class="keyword">const</span> string&amp;) = 0;

<span class="keywordtype">void</span> ErrorMessage (<span class="keyword">const</span> string&amp; Titul, <span class="keyword">const</span> string&amp; Message)
{
        <span class="keywordflow">if</span> (GlobalErrorMessage)
        {
                string q = Titul + <span class="stringliteral">":"</span>+Message;
                <span class="keywordflow">if</span> (q.empty()|| (q[q.length() -1]!=<span class="charliteral">'\n'</span>))       q+=<span class="charliteral">'\n'</span>;
                GlobalErrorMessage(q);
                <span class="keywordflow">return</span>;
        };
        
<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">                #ifndef _CONSOLE</span>
<span class="preprocessor"></span>                        MessageBox(0, Message.c_str(), Titul.c_str(), MB_OK);
                        <span class="keywordflow">return</span>;
<span class="preprocessor">                #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>
        string q = Message;
        <span class="keywordflow">if</span> (q.empty()|| (q[q.length() -1]!=<span class="charliteral">'\n'</span>))       q+=<span class="charliteral">'\n'</span>;
        fprintf(stderr, <span class="stringliteral">"%s: %s"</span>, Titul.c_str(), q.c_str());
        
};

<span class="keywordtype">void</span> ErrorMessage (<span class="keyword">const</span> string&amp; Message)
{
        ErrorMessage(<span class="stringliteral">"error"</span>, Message);
};

string MakeFName ( <span class="keyword">const</span> string&amp; InpitFileName,  <span class="keyword">const</span> string&amp; Ext)
{
        string Result = InpitFileName;
        size_t i = Result.find_last_of(<span class="charliteral">'.'</span>); <span class="comment">// найти последнее расширение</span>
        <span class="keywordflow">if</span> ( i  != string::npos) 
                Result.erase(i);        
        Result += string(<span class="stringliteral">"."</span>) ;
        Result += Ext;
        <span class="keywordflow">return</span> Result;
}







<span class="keywordtype">bool</span> MakePath (<span class="keywordtype">char</span>* RossPath, <span class="keywordtype">char</span>* FileName, <span class="keywordtype">char</span>* FullPath)
{ 
        <span class="keywordflow">if</span> (!RossPath || !FileName || !FullPath) <span class="keywordflow">return</span> <span class="keyword">false</span>;

        strcpy(FullPath,RossPath);

<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>
                <span class="keywordflow">if</span> (             (FullPath[strlen(FullPath) - 1] != <span class="charliteral">'\\'</span>) 
                                &amp;&amp;      (FullPath[strlen(FullPath) - 1] != <span class="charliteral">'/'</span>) 
                        )
                        strcat (FullPath,<span class="stringliteral">"\\"</span>);
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>
                <span class="keywordflow">if</span> (FullPath[strlen(FullPath) - 1] != <span class="charliteral">'/'</span>)
                        strcat (FullPath,<span class="stringliteral">"/"</span>);

<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>
        strcat (FullPath, FileName);      

        <span class="keywordflow">return</span>  FileExists(FullPath);
};

string GetPathByFile (string FileName)
{ 
  size_t i = FileName.rfind(<span class="stringliteral">"\\"</span>);        
  size_t j = FileName.rfind(<span class="stringliteral">"/"</span>);         

  <span class="keywordflow">if</span> (                  (i == string::npos) 
                &amp;&amp;              (j == string::npos)
          )
          <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
  <span class="keywordflow">else</span>
          <span class="keywordflow">if</span> (i == string::npos) 
                  <span class="keywordflow">return</span> FileName.substr(0, j+1);
          <span class="keywordflow">else</span>
                <span class="keywordflow">if</span> (j == string::npos) 
                        <span class="keywordflow">return</span> FileName.substr(0, i+1);
                <span class="keywordflow">else</span>
                        <span class="keywordflow">return</span> FileName.substr(0, max(i,j)+1); 
};


<span class="keywordtype">bool</span> IsBinFile (<span class="keyword">const</span> <span class="keywordtype">char</span>* FileName)
{
        <span class="keywordflow">return</span>      FileName 
                    &amp;&amp;  (strlen (FileName) &gt; 3)
                    &amp;&amp;  !strncmp (FileName+strlen(FileName) - 3, <span class="stringliteral">"bin"</span>, 3);
};

string  CreateTempFileName()
{
        <span class="keywordtype">char</span> tmpfilename[_MAX_PATH];
<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>                tmpnam(tmpfilename);
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>                <span class="keyword">const</span> <span class="keywordtype">char</span> * sTempPath = getenv(<span class="stringliteral">"TMP"</span>);
                <span class="keywordflow">if</span> (sTempPath)
                {
                        strcpy(tmpfilename, sTempPath);
                        <span class="keywordflow">if</span> (tmpfilename[strlen(tmpfilename)-1] != <span class="charliteral">'/'</span>)
                                strcat (tmpfilename,<span class="stringliteral">"/"</span>);
                        strcat (tmpfilename,<span class="stringliteral">"rml-temp.XXXXXX"</span>);
                }
                <span class="keywordflow">else</span>
            strcpy(tmpfilename, <span class="stringliteral">"/tmp/rml-temp.XXXXXX"</span>);        
                
                <span class="keywordtype">int</span> fd = mkstemp(tmpfilename);
                <span class="keywordflow">if</span> (fd == -1)
                        <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot create temp file"</span>);
                close (fd);
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">return</span> tmpfilename;

};


<span class="keywordtype">void</span> rml_TRACE( <span class="keyword">const</span> <span class="keywordtype">char</span>* format, ... )
{

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #ifdef _DEBUG</span>
<span class="preprocessor"></span>              va_list arglst;
          <span class="keywordtype">char</span> s[2000];
                  <span class="keywordflow">if</span> (strlen (format) &gt;  200)
                  {
                          OutputDebugString(<span class="stringliteral">"!!!!! too long debug line!!!"</span>);
                          <span class="keywordflow">return</span>;
                  };

          va_start( arglst, format );
              vsprintf( s, format, arglst);
              va_end( arglst );
                  OutputDebugString(s);
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>};


<span class="keywordtype">bool</span> IsEmptyLine ( <span class="keyword">const</span> <span class="keywordtype">char</span> *t)
{
        <span class="keywordflow">if</span> (*t==0) <span class="keywordflow">return</span> <span class="keyword">true</span>;

        <span class="keywordflow">while</span> (*t != <span class="charliteral">'\r'</span>)
        {
                <span class="keywordflow">if</span> ( (BYTE) t[0]&gt;<span class="charliteral">' '</span>) 
                        <span class="keywordflow">return</span> <span class="keyword">false</span>;

                t++;
        }

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keywordtype">char</span>* rtrim (<span class="keywordtype">char</span>* s)
{
        size_t len = strlen(s);

        <span class="keywordflow">while</span> ( len &gt; 0 &amp;&amp; isspace((BYTE)s[len-1]))
                s[--len] = 0;

        <span class="keywordflow">return</span> s;

}





<span class="comment">// ================== IsSuperEqualChar проверяет, что символы равны с точностью до регистра</span>
<span class="comment">//  и с точностью до "языка", m.е. латинское "a" будет равно  русскому "а".</span>
<span class="keywordtype">bool</span> IsSuperEqualChar (BYTE ch1, BYTE ch2, MorphLanguageEnum langua)
{
        <span class="keywordflow">if</span>      (               (ch1 == ch2) 
                        ||      (ch1 == ReverseChar(ch2, langua))
                ) 
        <span class="keywordflow">return</span> <span class="keyword">true</span>;

        <span class="keyword">const</span> size_t LenEF    = 53;
        <span class="comment">//  первая буква - прописная  кириллическая буква, что необходимо,</span>
        <span class="comment">// чтобы установить порядок на полях эквивалентности букв</span>
        <span class="keywordtype">char</span> <span class="keyword">const</span> EF[LenEF+1] = <span class="stringliteral">"\0аАaA\0еЕEe\0зЗ3\0кКKk\0мМM\0нНH\0оОOo0\0рРpP\0сСCc\0уУy\0хХXx"</span>;

        size_t i = 0, k=0;
        <span class="keywordflow">for</span> (i=0; i&lt;LenEF; i++)
                <span class="keywordflow">if</span> (!EF[i]) 
                        k = i+1;
                <span class="keywordflow">else</span>
                {
                        <span class="keywordflow">if</span> (ch1 == (BYTE)EF[i]) ch1 = (BYTE)EF[k];
                        <span class="keywordflow">if</span> (ch2 == (BYTE)EF[i]) ch2 = (BYTE)EF[k];
                }

        <span class="keywordflow">if</span> (is_russian_upper(ch1))
                ch1 = rtolower(ch1);

        <span class="keywordflow">if</span> (is_russian_upper(ch2))
                ch2 = rtolower(ch2);

        <span class="keywordflow">if</span> (is_english_upper (ch1))
                ch1 = tolower (ch1);

        <span class="keywordflow">if</span> (is_english_upper (ch2))
                ch2 = tolower (ch2);

        <span class="keywordflow">return</span> ch1 == ch2;
}




<span class="comment">/* сравнивает строки с помощью предиката IsSuperEqualChar */</span>
<span class="comment">// возращает true, если строки одинаковы</span>
<span class="keywordtype">bool</span> strscmp ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t l, MorphLanguageEnum langua)
{
        <span class="keywordflow">for</span>     (       ;
                        (               (l &gt; 0)
                                &amp;&amp;      IsSuperEqualChar((BYTE)*s1,(BYTE)*s2, langua) 
                                &amp;&amp;      *s1 
                                &amp;&amp;      *s2  
                        );
                        s1++,s2++,l--
                );
        <span class="comment">//если обе строки закончились</span>
        <span class="keywordflow">return</span> (!*s1 &amp;&amp; !*s2);
}

<span class="comment">// == strincmp</span>
<span class="keywordtype">int</span> CompareWithoutRegister ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t l, MorphLanguageEnum langua)
{
        <span class="keywordflow">for</span>     (       ;
                        (               (l &gt; 0)
                                &amp;&amp;      (       ( (BYTE)*s1 == (BYTE)*s2)
                                     || ( (BYTE)*s1 == ReverseChar((BYTE)*s2, langua) )
                                        )
                                &amp;&amp;      *s1 
                                &amp;&amp;      *s2  
                        );
                        s1++,s2++,l--
                );

        <span class="keywordflow">if</span> (l == 0) <span class="keywordflow">return</span> 0;

        <span class="keywordflow">if</span> (*s1 &lt; *s2)
                <span class="keywordflow">return</span> -1;
        <span class="keywordflow">else</span>
                <span class="keywordflow">if</span> (*s1 &gt; *s2)
                        <span class="keywordflow">return</span> 1;
                <span class="keywordflow">else</span>
                        <span class="keywordflow">return</span> 0;
}





BYTE force_rus_char (BYTE ch)
{
        <span class="comment">// в первой строке находятся латинские буквы, который могут быть заменены на</span>
        <span class="comment">// русские</span>
        <span class="keywordtype">char</span> search[] = <span class="stringliteral">"AaEe3KkMHOoPpCcyXx"</span>;
        <span class="comment">// во второй строке находятся русские</span>
        <span class="keywordtype">char</span> replace[] = <span class="stringliteral">"АаЕеЗКкМНОоРрСсуХх"</span>;

        <span class="keywordtype">char</span> *t = strchr (search,ch);

        <span class="keywordflow">if</span> (t == 0) <span class="keywordflow">return</span> 0;

        <span class="keywordflow">return</span> replace[(size_t) ((<span class="keywordtype">char</span>*)t- (<span class="keywordtype">char</span>*)search)];
}



<span class="keywordtype">bool</span> force_to_rus (<span class="keywordtype">char</span>* dest, <span class="keyword">const</span> <span class="keywordtype">char</span>* sour, size_t len)
{
        BYTE ch = 0 ;

        <span class="keywordflow">for</span> (size_t i=0; i &lt; len; i++)
                <span class="keywordflow">if</span>  (is_russian_alpha((BYTE)sour[i]))
                        dest[i] = sour[i];
                <span class="keywordflow">else</span>
                        <span class="keywordflow">if</span> ((ch = force_rus_char((BYTE)sour[i])) != 0)
                                dest[i] = ch;
                        <span class="keywordflow">else</span>
                                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keywordtype">char</span>* IntToStr (<span class="keywordtype">int</span> Value, <span class="keywordtype">char</span>* Buffer)
{
        sprintf (Buffer, <span class="stringliteral">"%i"</span>, Value);
        <span class="keywordflow">return</span> Buffer;
};

string&amp; IntToStr (<span class="keywordtype">int</span> Value, string&amp; oBuffer)
{
        <span class="keywordtype">char</span> Buffer[256];
        sprintf (Buffer, <span class="stringliteral">"%i"</span>, Value);
        oBuffer = Buffer;
        <span class="keywordflow">return</span> oBuffer;
};

<span class="preprocessor">#ifndef WIN32</span>
<span class="preprocessor"></span><span class="keywordtype">void</span> strrev(<span class="keywordtype">char</span>* s)
{
  <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span>;
  size_t len = strlen(s);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; len/2; i++)
    {
      swap(s[i], s[len - i - 1]);
    }

};
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>


<span class="keywordtype">bool</span> IsHtmlFile (<span class="keyword">const</span> string&amp; FileName)
{
        size_t len = FileName.length();
        string R = FileName;
        EngMakeLower(R);

        <span class="keywordflow">return</span> (   (len &gt; 4)
                        &amp;&amp; (   !strcmp (FileName.c_str()+len-3, <span class="stringliteral">"htm"</span>)
                            || !strcmp (FileName.c_str()+len-4, <span class="stringliteral">"html"</span>)
                                || !strcmp (FileName.c_str()+len-5, <span class="stringliteral">"shtml"</span>)
                           )
                   );
}


<span class="keywordtype">void</span> AddFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* MainFile, <span class="keyword">const</span> <span class="keywordtype">char</span>* ToAdd)
{
        <span class="keywordtype">char</span> s[_MAX_PATH*2];
<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>                sprintf (s, <span class="stringliteral">"type %s  &gt;&gt; %s "</span>, ToAdd, MainFile);
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>                sprintf (s, <span class="stringliteral">"cat %s  &gt;&gt; %s "</span>, ToAdd, MainFile);
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        system (s);

};


<span class="keyword">class </span>CRegistryExpc
{
 <span class="keyword">public</span>:
        string m_strCause;

        CRegistryExpc(string  strCause) 
        { 
        m_strCause =  strCause;
     };
        CRegistryExpc(<span class="keyword">const</span> CRegistryExpc&amp; from)
        {
                *<span class="keyword">this</span> = from;
        }
        CRegistryExpc&amp; operator= (<span class="keyword">const</span> CRegistryExpc&amp; from)
        {
                m_strCause = from.m_strCause;
                <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

};

<span class="keyword">const</span> <span class="keywordtype">char</span> RML_DIRECTORY_VARIABLE[] = <span class="stringliteral">"RML"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> RML_REGISTRY_FILENAME[] = <span class="stringliteral">"rml.ini"</span>;

<span class="keyword">static</span> string GetStringInnerFromTheFile (string RegistryPath, string MainPath, string RmlPath) 
{
        string FileName =       MainPath +  <span class="stringliteral">"/"</span> + RML_REGISTRY_FILENAME;
        FILE* fp = fopen (FileName.c_str(), <span class="stringliteral">"r"</span>);
        <span class="keywordflow">if</span> (fp == 0)
                <span class="keywordflow">throw</span> CRegistryExpc (<span class="stringliteral">"Cannot open "</span>+FileName);
        <span class="keywordtype">char</span> buffer[2048];
        <span class="keywordflow">while</span> (fgets(buffer,2048,fp))
        {
                string s = buffer;
                Trim(s);
                <span class="keywordflow">if</span> (s.empty()) <span class="keywordflow">continue</span>;
                size_t end_field_name = strcspn(s.c_str(), <span class="stringliteral">" \t"</span>);
                <span class="keywordflow">if</span> (end_field_name == s.length())
                {
                        fclose(fp);
                        <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot parse line "</span>+s);
                };
                string Key = s.substr(0,end_field_name);
                <span class="keywordflow">if</span> (RegistryPath == Key)
                {
                        string Value = s.substr(end_field_name);
                        Trim(Value);
                        <span class="keywordflow">if</span> (Value.substr(0, 4) == <span class="stringliteral">"$RML"</span>)
                                Value.replace(0,4, RmlPath);

                        fclose(fp);
                        <span class="keywordflow">return</span> Value;
                };
        };
        fclose (fp);

        <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
};

string GetIniFilePath()
{
        <span class="keyword">const</span> <span class="keywordtype">char</span> * sMainPath = getenv(RML_DIRECTORY_VARIABLE);
        <span class="keywordflow">if</span> (sMainPath == 0)
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot find a system variable \"RML\"!"</span>);
        string S = sMainPath;
        Trim(S);
        <span class="keywordflow">if</span> (S.empty())
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"system variable \"RML\" is not properly initialized!"</span>);
        
        <span class="keywordflow">if</span> (    (S[S.length()-1]!= <span class="charliteral">'/'</span>) &amp;&amp; (S[S.length()-1]!= <span class="charliteral">'\\'</span>) )
                S += <span class="stringliteral">"/"</span>;

        S += <span class="stringliteral">"Bin"</span>;
        <span class="keywordflow">return</span> S;
};

string GetRegistryString (string RegistryPath)
{
        string Result = GetStringInnerFromTheFile(RegistryPath, GetIniFilePath(), getenv(RML_DIRECTORY_VARIABLE));
        <span class="keywordflow">return</span> Result;
};

string GetRegistryStringFromLocalIniFile (string RegistryPath)
{
        string  Result = GetStringInnerFromTheFile(RegistryPath, <span class="stringliteral">"."</span>, <span class="stringliteral">"$RML"</span>);
        <span class="keywordflow">return</span> Result;
};

<span class="keywordtype">bool</span> CanGetRegistryString (string RegistryPath)  
{
        <span class="keywordflow">try</span> {
                string s = GetRegistryString(RegistryPath);
                <span class="keywordflow">return</span>  s != <span class="stringliteral">""</span>;
        }
        <span class="keywordflow">catch</span> (...)
        {
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };
}


<span class="keywordtype">void</span> SetRegistryString (string RegistryPath, string Value)
{  
        <span class="keywordflow">if</span> (RegistryPath.find(<span class="charliteral">' '</span>) != -1) 
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"A registry path cannot contain spaces"</span>);

        string FileName = GetIniFilePath() + <span class="stringliteral">"/"</span> + RML_REGISTRY_FILENAME;

        FILE* fp = fopen (FileName.c_str(), <span class="stringliteral">"r"</span>);
        <span class="keywordflow">if</span> (fp == 0)
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot open "</span>+FileName);
        string TempFileName = CreateTempFileName();
        FILE* outfp = fopen (TempFileName.c_str(), <span class="stringliteral">"w"</span>);
        <span class="keywordflow">if</span> (!outfp) 
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot open temporary file for setting variables in Registry"</span>);

        <span class="keywordtype">char</span> buffer[2048];

        <span class="keywordflow">while</span> (fgets(buffer,2048,fp))
        {
                string s = buffer;
                Trim(s);
                <span class="keywordflow">if</span> (s.empty()) <span class="keywordflow">continue</span>;
                size_t end_field_name = strcspn(s.c_str(), <span class="stringliteral">" \t"</span>);
                <span class="keywordflow">if</span> (end_field_name == s.length()) 
                {
                        fclose(fp);
                        remove (TempFileName.c_str());
                        <span class="keywordflow">throw</span> CRegistryExpc (<span class="stringliteral">"Cannot parse line "</span>+s);
                };

                <span class="keywordflow">if</span> (RegistryPath != s.substr(0,end_field_name))
                        fprintf (outfp, <span class="stringliteral">"%s\n"</span>, s.c_str());
        };

        fprintf (outfp, <span class="stringliteral">"%s %s\n"</span>, RegistryPath.c_str(), Value.c_str());

        
        fclose(fp);
        fclose(outfp);

        remove (FileName.c_str());

        <span class="keywordflow">if</span> (rename(TempFileName.c_str(), FileName.c_str())!=0)
                <span class="keywordflow">throw</span> CExpc (<span class="stringliteral">"Cannot rename temporary file for setting variables to main file"</span>);


};


<span class="keywordtype">bool</span>    IsRmlRegistered(string&amp; Error)
{
        <span class="keyword">const</span> <span class="keywordtype">char</span> * sMainPath = getenv(RML_DIRECTORY_VARIABLE);
        <span class="keywordflow">if</span> (sMainPath == 0)
        {
                Error = <span class="stringliteral">"Variable \"RML\" is not registered! Abort!\n"</span>;
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };

        string IniFile = GetIniFilePath() +  <span class="stringliteral">"/"</span> + RML_REGISTRY_FILENAME;
        <span class="keywordflow">if</span> (!FileExists(IniFile.c_str() ))
        {
                Error = <span class="stringliteral">"ini file not found: "</span> + IniFile;
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};

<span class="keyword">struct </span>tm  RmlGetCurrentTime ()
{
        time_t ltime;
        time( &amp;ltime );
<span class="preprocessor">        #ifdef  WIN32</span>
<span class="preprocessor"></span>                <span class="keyword">struct </span>tm *today;
                today = localtime( &amp;ltime );
                <span class="keywordflow">return</span> *today;
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>                <span class="comment">//  we should  thread safe  variants</span>
                <span class="keyword">struct </span>tm today;
                localtime_r( &amp;ltime, &amp;today );
                <span class="keywordflow">return</span> today;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>};


<span class="keywordtype">bool</span> CheckEvaluationTime ()
{
        tm today = RmlGetCurrentTime();

        <span class="comment">//  2005 year</span>
        <span class="keywordflow">if</span> (today.tm_year &gt; 106)
        {
                ErrorMessage(<span class="stringliteral">"Evaluation period is expired. Write to sokirko@yandex.ru!"</span>);
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};


<span class="comment">//=======================           Morphology  =======================</span>

<span class="keyword">const</span> <span class="keywordtype">int</span> predict_poses_size = 4;

<span class="comment">//  we cannot use here class string, because VC7 shows in this case memory leaks</span>
<span class="keyword">struct </span>CPredictPartOfSpeech {
        <span class="keywordtype">char</span> m_pos_str[100];
};
<span class="keyword">const</span> CPredictPartOfSpeech  predict_rus_pos[predict_poses_size] =
{
        <span class="stringliteral">"С"</span>,
        <span class="stringliteral">"ИНФИНИТИВ"</span>,
        <span class="stringliteral">"П"</span>,
        <span class="stringliteral">"Н"</span>,
};

<span class="keyword">const</span> CPredictPartOfSpeech predict_eng_pos[predict_poses_size] =
{
        <span class="stringliteral">"NOUN"</span>,
        <span class="stringliteral">"VERB"</span>,
        <span class="stringliteral">"ADJECTIVE"</span>,
        <span class="stringliteral">"ADVERB"</span>,
};
<span class="keyword">const</span> CPredictPartOfSpeech predict_ger_pos[predict_poses_size] =
{
        <span class="stringliteral">"SUB"</span>,
        <span class="stringliteral">"VER"</span>,
        <span class="stringliteral">"ADJ"</span>,
        <span class="stringliteral">"ADV"</span>,
};


<span class="keywordtype">int</span> GetPredictionPartOfSpeech(<span class="keyword">const</span> string&amp; PartOfSpeech, MorphLanguageEnum langua)
{
        <span class="keyword">const</span> CPredictPartOfSpeech* PossiblePoses;
        <span class="keywordflow">switch</span> (langua)
        {
                <span class="keywordflow">case</span> morphEnglish: PossiblePoses = predict_eng_pos; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> morphGerman: PossiblePoses = predict_ger_pos; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> morphRussian: PossiblePoses = predict_rus_pos; <span class="keywordflow">break</span>;
                <span class="keywordflow">default</span> : assert(<span class="keyword">false</span>);
        };


        <span class="keywordtype">int</span> k=0;
        <span class="keywordflow">for</span>(; k &lt; predict_poses_size; k++ )
                <span class="keywordflow">if</span>( PartOfSpeech == PossiblePoses[k].m_pos_str )
                {
                        <span class="keywordflow">break</span>;
                };

        <span class="keywordflow">if</span> (k == predict_poses_size)
                <span class="keywordflow">return</span> UnknownPartOfSpeech;
        <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> k;
};


<span class="keywordtype">bool</span> GetLanguageByString (string s, MorphLanguageEnum&amp; Result)
{
        
        EngRusMakeUpper(s);

        <span class="keywordflow">if</span>(s == <span class="stringliteral">"RUSSIAN"</span>){
                Result = morphRussian;
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(s == <span class="stringliteral">"ENGLISH"</span>){
                Result = morphEnglish;
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(s == <span class="stringliteral">"GERMAN"</span>){
                Result = morphGerman;
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(s == <span class="stringliteral">"GENERIC"</span>){
                Result = morphGeneric;
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }<span class="keywordflow">else</span> 
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        
};

string GetStringByLanguage (MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua) {
                <span class="keywordflow">case</span> morphRussian: <span class="keywordflow">return</span>  <span class="stringliteral">"Russian"</span>;
                <span class="keywordflow">case</span> morphEnglish: <span class="keywordflow">return</span>  <span class="stringliteral">"English"</span>;
                <span class="keywordflow">case</span> morphGerman: <span class="keywordflow">return</span>  <span class="stringliteral">"German"</span>;
                <span class="keywordflow">case</span> morphGeneric: <span class="keywordflow">return</span>  <span class="stringliteral">"Generic"</span>;
                <span class="keywordflow">default</span> :<span class="keywordflow">return</span> <span class="stringliteral">"unk"</span>;
        }
};

<span class="comment">//=================================================================</span>
<span class="comment">//===================  STRINGS =====================================</span>
<span class="comment">//=================================================================</span>


<span class="keywordtype">bool</span> is_upper_roman_digit (BYTE ch)
{ 
        <span class="keywordflow">return</span>  (ASCII[ch]&amp;UpRomDigits)&gt;0; 
}

<span class="keywordtype">bool</span> is_lower_roman_digit (BYTE ch)
{ 
        <span class="keywordflow">return</span> (ASCII[ch]&amp;LwRomDigits) &gt; 0; 
}


<span class="keywordtype">bool</span> is_roman_number ( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t len)
{
        <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordtype">bool</span> bLowRoman = <span class="keyword">true</span>;
        <span class="keywordtype">bool</span> bUpperRoman = <span class="keyword">true</span>;
        <span class="keywordflow">for</span>(size_t i=0; i&lt;len; i++)
        {
                <span class="keywordflow">if</span> ( (i&gt;0) &amp;&amp; (s[i] == <span class="charliteral">'-'</span>) &amp;&amp; (i+3&gt;=len)) <span class="comment">//  окончания пишутся после дефиса, типа "Павла I-го"</span>
                {
                        <span class="keywordflow">return</span> bLowRoman || bUpperRoman;
                };

                bLowRoman = bLowRoman &amp;&amp; ((ASCII[(BYTE)s[i]]&amp;LwRomDigits)&gt;0);
                bUpperRoman = bUpperRoman &amp;&amp; ((ASCII[(BYTE)s[i]]&amp;UpRomDigits)&gt;0);
                
        };
        <span class="keywordflow">return</span>    bLowRoman || bUpperRoman;
}

<span class="comment">//  =============  Punctuation Letters ======================</span>
<span class="keywordtype">bool</span> is_spc_fill (BYTE x)
{
        <span class="keywordflow">return</span> ((x)==<span class="charliteral">' '</span>||(x)==<span class="charliteral">'_'</span>); 
};

<span class="comment">//====================================================</span>
<span class="comment">//============= ENGLISH                   ============</span>
<span class="comment">//====================================================</span>

<span class="keyword">const</span> BYTE  Ccedille = 199;
<span class="keyword">const</span> BYTE  Egravis = 200;
<span class="keyword">const</span> BYTE  Ezirkun = 202;
<span class="keyword">const</span> BYTE  Azirkun = 194;
<span class="keyword">const</span> BYTE  Ozirkun = 212;
<span class="keyword">const</span> BYTE  Ntilda = 209;
<span class="keyword">const</span> BYTE  Eakut = 201;
<span class="keyword">const</span> BYTE  Uzirkun = 219;

<span class="keyword">const</span> BYTE  ccedille = 231;
<span class="keyword">const</span> BYTE  egravis = 232;
<span class="keyword">const</span> BYTE  ezirkun = 234;
<span class="keyword">const</span> BYTE  azirkun = 226;
<span class="keyword">const</span> BYTE  ozirkun = 244;
<span class="keyword">const</span> BYTE  ntilda = 241;
<span class="keyword">const</span> BYTE  eakut = 233;
<span class="keyword">const</span> BYTE  uzirkun = 251;

<span class="keywordtype">bool</span> is_generic_upper(BYTE x)     
{
        <span class="comment">// why ,,</span>
        <span class="keywordflow">return</span>          (ASCII[x]&amp;EngUpper)&gt;0;
}; 
 
<span class="keywordtype">bool</span> is_generic_lower(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;EngLower)&gt;0 || x&gt;=128;
};

<span class="keywordtype">bool</span> is_generic_alpha(BYTE x)      
{
        <span class="keywordflow">return</span> is_english_alpha(x) || x&gt;=128; 
};


<span class="keywordtype">bool</span> is_english_upper(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;EngUpper)&gt;0;
}; 

<span class="keywordtype">bool</span> is_english_upper_vowel(BYTE x)
{
        <span class="keywordflow">return</span>                  ((ASCII[x] &amp; EngUpper)&gt;0)
                                &amp;&amp;      ((ASCII[x] &amp; LatinVowel)&gt;0);
};


<span class="keywordtype">bool</span> is_english_lower(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;EngLower)&gt;0;
}; 

<span class="keywordtype">bool</span> is_english_lower_vowel(BYTE x)     
{
        <span class="keywordflow">return</span>                  ( (ASCII[x] &amp; EngLower)&gt;0)
                                &amp;&amp;      ( (ASCII[x] &amp; LatinVowel)&gt;0);
};

<span class="keywordtype">bool</span> is_english_alpha(BYTE x)      
{
        <span class="keywordflow">return</span> is_english_lower(x) || is_english_upper(x); 
};

BYTE etoupper (BYTE ch)
{
        <span class="keywordflow">if</span> (ch&gt;=(BYTE) <span class="charliteral">'a'</span> &amp;&amp; ch&lt;= (BYTE) <span class="charliteral">'z'</span>)
                <span class="keywordflow">return</span> ch -= <span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>;
        <span class="keywordflow">else</span>
        <span class="keywordflow">switch</span> (ch) {
                <span class="keywordflow">case</span> ccedille : <span class="keywordflow">return</span> Ccedille; <span class="comment">// C with cedille</span>
                <span class="keywordflow">case</span> egravis : <span class="keywordflow">return</span> Egravis;  <span class="comment">// E with gravis</span>
                <span class="keywordflow">case</span> ezirkun : <span class="keywordflow">return</span> Ezirkun;  <span class="comment">// E with zirkun</span>
                <span class="keywordflow">case</span> azirkun : <span class="keywordflow">return</span> Azirkun;  <span class="comment">// A with zirkun</span>
                <span class="keywordflow">case</span> ozirkun : <span class="keywordflow">return</span> Ozirkun;  <span class="comment">// O with zirkun</span>
                <span class="keywordflow">case</span> ouml : <span class="keywordflow">return</span> Ouml;  <span class="comment">// O umlaut</span>
                <span class="keywordflow">case</span> ntilda : <span class="keywordflow">return</span> Ntilda;  <span class="comment">// N with tilda</span>
                <span class="keywordflow">case</span> uzirkun : <span class="keywordflow">return</span> Uzirkun;  <span class="comment">// U with zirkun</span>
                <span class="keywordflow">case</span> eakut : <span class="keywordflow">return</span> Eakut;  <span class="comment">// E acut</span>
                <span class="keywordflow">default</span> : <span class="keywordflow">return</span> ch;
        };
};


BYTE etolower (BYTE ch)
{
        <span class="keywordflow">if</span> (ch&gt;=(BYTE) <span class="charliteral">'A'</span> &amp;&amp; ch&lt;= (BYTE) <span class="charliteral">'Z'</span>)
                <span class="keywordflow">return</span> ch += <span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>;
        <span class="keywordflow">else</span>
        <span class="keywordflow">switch</span> (ch) {
                <span class="keywordflow">case</span> Ccedille : <span class="keywordflow">return</span> ccedille; <span class="comment">// C with cedille</span>
                <span class="keywordflow">case</span> Egravis : <span class="keywordflow">return</span> egravis;  <span class="comment">// E with gravis</span>
                <span class="keywordflow">case</span> Ezirkun : <span class="keywordflow">return</span> ezirkun;  <span class="comment">// E with zirkun</span>
                <span class="keywordflow">case</span> Azirkun : <span class="keywordflow">return</span> azirkun;  <span class="comment">// A with zirkun</span>
                <span class="keywordflow">case</span> Ozirkun : <span class="keywordflow">return</span> ozirkun;  <span class="comment">// O with zirkun</span>
                <span class="keywordflow">case</span> Ouml : <span class="keywordflow">return</span> ouml;  <span class="comment">// O umlaut</span>
                <span class="keywordflow">case</span> Ntilda : <span class="keywordflow">return</span> ntilda;  <span class="comment">// N with tilda</span>
                <span class="keywordflow">case</span> Uzirkun : <span class="keywordflow">return</span> uzirkun;  <span class="comment">// U with zirkun</span>
                <span class="keywordflow">case</span> Eakut : <span class="keywordflow">return</span> eakut;  <span class="comment">// E acut</span>
                <span class="keywordflow">default</span> : <span class="keywordflow">return</span> ch;
        };
};


<span class="comment">//====================================================</span>
<span class="comment">//============= GERMAN                  ============</span>
<span class="comment">//====================================================</span>
 
<span class="keywordtype">bool</span> is_german_upper(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;GerUpper) &gt; 0;
}; 

<span class="keywordtype">bool</span> is_german_lower(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;GerLower) &gt; 0;
}; 




<span class="keywordtype">bool</span> is_german_lower_vowel(BYTE x)     
{
        <span class="keywordflow">return</span>                  (ASCII[x] &amp; GerLower)
                                &amp;&amp;      (ASCII[x] &amp; LatinVowel);
};

<span class="keywordtype">bool</span> is_german_upper_vowel(BYTE x)
{
        <span class="keywordflow">return</span>                  (ASCII[x] &amp; GerUpper)
                                &amp;&amp;      (ASCII[x] &amp; LatinVowel);

};

<span class="keywordtype">bool</span> is_german_alpha(BYTE x)      
{
        <span class="keywordflow">return</span> is_german_lower(x) || is_german_upper(x); 
};

BYTE gtoupper (BYTE ch) 
{ 
        <span class="keywordflow">if</span> (is_english_lower (ch)) 
                <span class="keywordflow">return</span> etoupper (ch);
        <span class="keywordflow">else</span>
                <span class="keywordflow">switch</span> (ch )
                 {
                        <span class="keywordflow">case</span> auml  : <span class="keywordflow">return</span> Auml;;
                        <span class="keywordflow">case</span> uuml  : <span class="keywordflow">return</span> Uuml;
                        <span class="keywordflow">case</span> ouml : <span class="keywordflow">return</span> Ouml;
                        <span class="keywordflow">default</span> : <span class="keywordflow">return</span> ch;
                 };
};
BYTE gtolower (BYTE ch) 
{ 
        <span class="keywordflow">if</span> (is_english_upper (ch)) 
                <span class="keywordflow">return</span> etolower (ch);
        <span class="keywordflow">else</span>
                <span class="keywordflow">switch</span> (ch )
                 {
                        <span class="keywordflow">case</span> Auml : <span class="keywordflow">return</span> auml;;
                        <span class="keywordflow">case</span> Uuml  : <span class="keywordflow">return</span> uuml;
                        <span class="keywordflow">case</span> Ouml  : <span class="keywordflow">return</span> ouml;
                        <span class="keywordflow">default</span> : <span class="keywordflow">return</span> ch;
                 };
};

<span class="comment">//====================================================</span>
<span class="comment">//============= RUSSIAN                  ============</span>
<span class="comment">//====================================================</span>

<span class="keywordtype">bool</span> is_russian_upper(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;RusUpper) &gt; 0;
};

<span class="keywordtype">bool</span> is_russian_lower(BYTE x)     
{
        <span class="keywordflow">return</span>          (ASCII[x]&amp;RusLower) &gt; 0;
};

<span class="keywordtype">bool</span> is_russian_lower_vowel(BYTE x)     
{
        <span class="keywordflow">return</span>                  ( (ASCII[x] &amp; RusLower) &gt; 0)
                                &amp;&amp;      ( (ASCII[x] &amp; RussianVowel) &gt; 0);

};
<span class="keywordtype">bool</span> is_russian_upper_vowel(BYTE x)
{
        <span class="keywordflow">return</span>                  ((ASCII[x] &amp; RusUpper) &gt; 0)
                                &amp;&amp;      ((ASCII[x] &amp; RussianVowel) &gt; 0);
};

<span class="keywordtype">bool</span> is_russian_lower_consonant(BYTE x) 
{
        <span class="keywordflow">return</span> !is_russian_lower_vowel(x) &amp;&amp;  is_russian_lower(x);
}
<span class="keywordtype">bool</span> is_russian_upper_consonant(BYTE x) 
{
        <span class="keywordflow">return</span> !is_russian_upper_vowel(x) &amp;&amp;  is_russian_upper(x);
}
<span class="keywordtype">bool</span> is_russian_consonant(BYTE x)  
{
        <span class="keywordflow">return</span> is_russian_lower_consonant(x) || is_russian_upper_consonant(x);
}


<span class="keywordtype">bool</span> is_russian_alpha(BYTE x)      
{
        <span class="keywordflow">return</span> is_russian_lower(x) || is_russian_upper(x); 
};

BYTE rtoupper (BYTE ch) 
{ 
        <span class="keywordflow">if</span> (ch == LowerJO) <span class="keywordflow">return</span> UpperJO;
        <span class="keywordflow">if</span> (ch == Apostrophe ) <span class="keywordflow">return</span> Apostrophe;

        <span class="keywordflow">if</span> ( is_russian_lower(ch) )
                <span class="keywordflow">return</span>  ch -= <span class="charliteral">'а'</span>-<span class="charliteral">'А'</span>;
        <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> ch;
};

BYTE rtolower (BYTE ch) 
{ 
        <span class="keywordflow">if</span> (ch == UpperJO) <span class="keywordflow">return</span> LowerJO;
        <span class="keywordflow">if</span> (ch == Apostrophe ) <span class="keywordflow">return</span> Apostrophe;

        <span class="keywordflow">if</span> ( is_russian_upper(ch) )
                <span class="keywordflow">return</span> ch += <span class="charliteral">'а'</span>-<span class="charliteral">'А'</span>;
        <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> ch;
};


<span class="comment">//========================================= ===========</span>
<span class="comment">//============= General encoding functions ============</span>
<span class="comment">//====================================================</span>

<span class="keywordtype">bool</span> is_lower_vowel(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua)
        {
                <span class="keywordflow">case</span> morphRussian : <span class="keywordflow">return</span> is_russian_lower_vowel(x);
                <span class="keywordflow">case</span> morphEnglish : <span class="keywordflow">return</span> is_english_lower_vowel(x);
                <span class="keywordflow">case</span> morphGerman : <span class="keywordflow">return</span> is_german_lower_vowel(x);
        };
        assert (<span class="keyword">false</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
};

<span class="keywordtype">bool</span> is_upper_vowel(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua)
        {
                <span class="keywordflow">case</span> morphRussian : <span class="keywordflow">return</span> is_russian_upper_vowel(x);
                <span class="keywordflow">case</span> morphEnglish : <span class="keywordflow">return</span> is_english_upper_vowel(x);
                <span class="keywordflow">case</span> morphGerman : <span class="keywordflow">return</span> is_german_upper_vowel(x);
        };
        assert (<span class="keyword">false</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
};

<span class="keywordtype">bool</span> is_lower_consonant(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">if</span> (!is_lower_alpha(x, Langua)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">return</span> !is_lower_vowel(x,Langua);
};

<span class="keywordtype">bool</span> is_upper_consonant(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">if</span> (!is_upper_alpha(x, Langua)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">return</span> !is_upper_vowel(x,Langua);
};

<span class="keywordtype">bool</span> is_alpha (BYTE x)       
{
        <span class="keywordflow">return</span> is_russian_alpha(x) || is_german_alpha(x); 
};


<span class="keywordtype">bool</span> is_alpha (BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua)
        {
                <span class="keywordflow">case</span> morphRussian : <span class="keywordflow">return</span> is_russian_alpha(x);
                <span class="keywordflow">case</span> morphEnglish : <span class="keywordflow">return</span> is_english_alpha(x);
                <span class="keywordflow">case</span> morphGerman : <span class="keywordflow">return</span> is_german_alpha(x);
                <span class="keywordflow">case</span> morphGeneric : <span class="keywordflow">return</span> is_generic_alpha(x);
        };
        assert (<span class="keyword">false</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
};

<span class="keywordtype">bool</span> is_lower_alpha(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua)
        {
                <span class="keywordflow">case</span> morphRussian : <span class="keywordflow">return</span> is_russian_lower(x);
                <span class="keywordflow">case</span> morphEnglish : <span class="keywordflow">return</span> is_english_lower(x);
                <span class="keywordflow">case</span> morphGerman : <span class="keywordflow">return</span> is_german_lower(x);
                <span class="keywordflow">case</span> morphGeneric : <span class="keywordflow">return</span> is_generic_lower(x);
        };
        assert (<span class="keyword">false</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
};

<span class="keywordtype">bool</span> is_upper_alpha(BYTE x, MorphLanguageEnum Langua)
{
        <span class="keywordflow">switch</span> (Langua)
        {
                <span class="keywordflow">case</span> morphRussian : <span class="keywordflow">return</span> is_russian_upper(x);
                <span class="keywordflow">case</span> morphEnglish : <span class="keywordflow">return</span> is_english_upper(x);
                <span class="keywordflow">case</span> morphGerman : <span class="keywordflow">return</span> is_german_upper(x);
                <span class="keywordflow">case</span> morphGeneric : <span class="keywordflow">return</span> is_generic_upper(x);
        };
        assert (<span class="keyword">false</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
};

<span class="keywordtype">bool</span> isnspace(BYTE x)    
{
        <span class="keywordflow">return</span> x==<span class="charliteral">' '</span> || x==<span class="charliteral">'\t'</span>;
};



BYTE ReverseChar (BYTE ch, MorphLanguageEnum langua)
{
   <span class="keywordflow">if</span>  (langua == morphGerman)
   {
           <span class="keywordflow">if</span> (is_english_lower (ch))
                   <span class="keywordflow">return</span> etoupper (ch);
           <span class="keywordflow">else</span>
                 <span class="keywordflow">if</span> (is_english_upper (ch))
                        <span class="keywordflow">return</span> etolower (ch);
                 <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (ch )
                 {
                        <span class="keywordflow">case</span> Auml  : <span class="keywordflow">return</span> auml;
                        <span class="keywordflow">case</span> auml  : <span class="keywordflow">return</span> Auml;;
                        <span class="keywordflow">case</span> Uuml  : <span class="keywordflow">return</span> uuml;
                        <span class="keywordflow">case</span> uuml  : <span class="keywordflow">return</span> Uuml;
                        <span class="keywordflow">case</span> Ouml  : <span class="keywordflow">return</span> ouml;
                        <span class="keywordflow">case</span> ouml  : <span class="keywordflow">return</span> Ouml;
                        <span class="keywordflow">default</span> : <span class="keywordflow">return</span> ch;
                 };
   }
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (langua == morphGeneric)
   {
           <span class="keywordflow">if</span> (is_english_lower (ch))
                   <span class="keywordflow">return</span> etoupper (ch);
           <span class="keywordflow">else</span>
                 <span class="keywordflow">if</span> (is_english_upper (ch))
                        <span class="keywordflow">return</span> etolower (ch);

    }
   <span class="keywordflow">else</span>
   <span class="keywordflow">if</span> (is_russian_lower(ch))
           <span class="keywordflow">return</span> rtoupper (ch);
   <span class="keywordflow">else</span>
     <span class="keywordflow">if</span> (is_russian_upper(ch))
                 <span class="keywordflow">return</span> rtolower(ch);
     <span class="keywordflow">else</span>
       <span class="keywordflow">if</span> (is_english_lower (ch))
                        <span class="keywordflow">return</span> etoupper (ch);
       <span class="keywordflow">else</span>
                        <span class="keywordflow">if</span> (is_english_upper (ch))
                                <span class="keywordflow">return</span> etolower (ch);

        <span class="keywordflow">return</span> ch;
};


<span class="comment">// конвертирует из прописной кириллицы в заглавную </span>
<span class="keywordtype">char</span>* RusMakeUpper (<span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, strlen(word), is_russian_lower, rtoupper);
}
<span class="comment">// конвертирует из прописной кириллицы в заглавную </span>
<span class="keywordtype">char</span>* EngMakeUpper (<span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, strlen(word), is_english_lower, etoupper);
}

string&amp; EngMakeUpper (string&amp; word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, word.length(), is_english_lower, etoupper);
}

string&amp; EngMakeLower (string&amp; word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, word.length(), is_english_upper, etolower);
}


<span class="keywordtype">char</span>* GerMakeUpper (<span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, strlen(word), is_german_lower, gtoupper);
}

string&amp; GerMakeUpper (string&amp; word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, word.length(), is_german_lower, gtoupper);
}

<span class="comment">// конвертирует из заглавной кириллицы в прописную </span>
<span class="keywordtype">char</span>* RusMakeLower (<span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> RegisterConverter(word, strlen(word), is_russian_upper, rtolower);
}


<span class="keyword">typedef</span> bool (*SymbolCheckerFunc) (BYTE);

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keywordtype">bool</span> CheckLanguage(<span class="keyword">const</span> T&amp; src, size_t Length, MorphLanguageEnum langua)
{
        SymbolCheckerFunc SymbolChecker = 0;

        <span class="keywordflow">switch</span> (langua) {
                <span class="keywordflow">case</span> morphRussian : SymbolChecker =  is_russian_alpha; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> morphGerman : SymbolChecker =  is_german_alpha; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> morphEnglish : SymbolChecker =  is_english_alpha; <span class="keywordflow">break</span>;
        };
        <span class="keywordflow">if</span> (!SymbolChecker) <span class="keywordflow">return</span> <span class="keyword">false</span>;

        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; Length; i++ )
        <span class="keywordflow">if</span> ( !SymbolChecker( (BYTE)src[i] )  )
                        <span class="keywordflow">if</span> ( (BYTE)src[i] != <span class="charliteral">'-'</span>) 
                                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};

<span class="keywordtype">bool</span> IsRussian (<span class="keyword">const</span> <span class="keywordtype">char</span> *word) 
{
        <span class="keywordflow">return</span> CheckLanguage(word, strlen(word), morphRussian);
}
<span class="keywordtype">bool</span> IsRussian (<span class="keyword">const</span> string&amp; word)
{
        <span class="keywordflow">return</span> CheckLanguage(word, word.length(), morphRussian);
}

<span class="keywordtype">bool</span> IsEnglish (<span class="keyword">const</span> <span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> CheckLanguage(word, strlen(word), morphEnglish);
}

<span class="keywordtype">bool</span> IsEnglish (<span class="keyword">const</span> string&amp; word)
{
        <span class="keywordflow">return</span> CheckLanguage(word, word.length(), morphEnglish);
}

<span class="keywordtype">bool</span> IsGerman (<span class="keyword">const</span> <span class="keywordtype">char</span> *word)
{
        <span class="keywordflow">return</span> CheckLanguage(word, strlen(word), morphGerman);
}
<span class="keywordtype">bool</span> IsGerman (<span class="keyword">const</span> string&amp; word)
{
        <span class="keywordflow">return</span> CheckLanguage(word, word.length(), morphGerman);
}

<span class="keywordtype">bool</span> CheckLanguage (<span class="keyword">const</span> <span class="keywordtype">char</span> *word, MorphLanguageEnum langua)
{
        <span class="keywordflow">return</span> CheckLanguage(word, strlen(word), langua);
};

<span class="keywordtype">bool</span> CheckLanguage (<span class="keyword">const</span> string&amp; word, MorphLanguageEnum langua)
{
        <span class="keywordflow">return</span> CheckLanguage(word, word.length(), langua);
};




<span class="comment">// конвертирует из прописные  кириллицы в строчную</span>
string&amp; EngRusMakeLower (string&amp; word)
{
        size_t len = word.length();

        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; len; i++ )
        <span class="keywordflow">if</span> ( is_russian_upper((BYTE)word[i]) )
            word[i] = rtolower ((BYTE)word[i]);
                <span class="keywordflow">else</span>
                        word[i] = etolower ((BYTE) word[i]);

        <span class="keywordflow">return</span> word;
}


<span class="comment">// конвертирует из прописные  кириллицы в строчную</span>
<span class="keywordtype">char</span>* EngRusMakeLower (<span class="keywordtype">char</span>* word)
{
        <span class="keywordflow">if</span> (word == 0) <span class="keywordflow">return</span> 0;
        size_t len =  strlen(word);
        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; len; i++ )
        <span class="keywordflow">if</span> ( is_russian_upper((BYTE)word[i]) )
                        word[i] = rtolower ((BYTE)word[i]);
                <span class="keywordflow">else</span>
                        word[i] = etolower ((BYTE) word[i]);

        <span class="keywordflow">return</span> word;
}



<span class="keywordtype">char</span>* RmlMakeUpper (<span class="keywordtype">char</span> *word, MorphLanguageEnum langua)
{
        <span class="keywordflow">if</span> (!word) <span class="keywordflow">return</span> word;
        <span class="keywordflow">return</span> GerEngRusMakeUpperTemplate(word, langua, strlen(word));
};      

string&amp; RmlMakeUpper (string&amp; word, MorphLanguageEnum langua)
{
        GerEngRusMakeUpperTemplate(word, langua, word.length());
        <span class="keywordflow">return</span> word;
};      

string&amp; RmlMakeLower (string&amp; word, MorphLanguageEnum langua)
{
        <span class="keywordflow">if</span> (word.length() == 0) <span class="keywordflow">return</span> word;

        <span class="keywordflow">if</span> (langua == morphGerman)
                <span class="keywordflow">return</span> RegisterConverter(word, word.length(), is_german_upper, gtolower);
        <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> EngRusMakeLower(word);
};      


<span class="comment">// конвертирует из строчной кириллицы в прописные </span>
string&amp;  EngRusMakeUpper (string&amp; word)
{
        size_t len = word.length();
        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; len; i++ )
        <span class="keywordflow">if</span> ( is_russian_lower((BYTE)word[i]) )
                        word[i] = rtoupper ((BYTE)word[i]);
                <span class="keywordflow">else</span>
                        word[i] = etoupper ((BYTE) word[i]);

        <span class="keywordflow">return</span> word;
}



<span class="comment">// конвертирует из строчной кириллицы в прописные </span>
<span class="keywordtype">char</span>*  EngRusMakeUpper (<span class="keywordtype">char</span>* word)
{
        <span class="keywordflow">if</span> (word == 0) <span class="keywordflow">return</span> 0;
        size_t len =  strlen(word);

        <span class="keywordflow">for</span>( size_t i = 0 ; i &lt; len; i++ )

        <span class="keywordflow">if</span> ( is_russian_lower((BYTE)word[i]) )
                        word[i] = rtoupper ((BYTE)word[i]);
                <span class="keywordflow">else</span>
         <span class="keywordflow">if</span> ( is_english_lower((BYTE)word[i]) )
                        word[i] = etoupper ((BYTE) word[i]);
                

        <span class="keywordflow">return</span> word;
}


<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keywordtype">void</span> ConvertJO2JeTemplate(T&amp; src, size_t Length)
{
        <span class="keywordflow">for</span> (size_t i = 0; i &lt; Length; i++)
        {
                <span class="keywordflow">if</span> ( ((BYTE)src[i]) == LowerJO)
                        src[i] = (BYTE)<span class="charliteral">'е'</span>;
                <span class="keywordflow">else</span>
                
                        <span class="keywordflow">if</span> ( ( (BYTE)src[i]) == UpperJO)
                        src[i] = (BYTE)<span class="charliteral">'Е'</span>;
        }

};

<span class="keywordtype">void</span> ConvertJO2Je(<span class="keywordtype">char</span>* src, size_t Length)
{
        ConvertJO2JeTemplate(src, Length);
};



<span class="keywordtype">void</span> ConvertJO2Je(string&amp; src) 
{

        ConvertJO2JeTemplate(src, src.length());
};
<span class="keywordtype">void</span> ConvertJO2Je(<span class="keywordtype">char</span>* src) 
{
        ConvertJO2JeTemplate(src, strlen(src));
};



<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #define VSNPRINTF _vsnprintf</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #define VSNPRINTF vsnprintf</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
string Format( <span class="keyword">const</span> <span class="keywordtype">char</span>* format, ... )
{
        va_list arglst;
        <span class="keyword">const</span> size_t  SmallBufferSize = 15000;
    <span class="keywordtype">char</span> SmallBuffer[SmallBufferSize+1];

    va_start( arglst, format );
        <span class="keywordtype">int</span>     OutputLength = VSNPRINTF( SmallBuffer, SmallBufferSize, format, arglst);

        va_end( arglst );

<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>                <span class="keywordflow">if</span> (OutputLength == -1)
                {
                        va_start( arglst, format );
                        OutputLength = _vscprintf( format, arglst);
                        va_end( arglst );
                };
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">if</span> (            (OutputLength == -1)
                        ||      (OutputLength &lt; SmallBufferSize)
                )
                <span class="keywordflow">return</span> SmallBuffer;

        <span class="keywordflow">if</span> (OutputLength &gt; 10000000) <span class="comment">// simlply we don't want to ruin the memory (10 Mb is enough)</span>
        {
                assert (<span class="keyword">false</span>);
                OutputLength = 10000000;
        };


        <span class="keywordtype">char</span> * pBuffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[OutputLength+2];
        <span class="keywordflow">if</span> (!pBuffer)
                <span class="keywordflow">return</span> SmallBuffer;
        va_start( arglst, format );
        VSNPRINTF( pBuffer, OutputLength+1, format, arglst);
        va_end( arglst );
        string Res = pBuffer;
        <span class="keyword">delete</span> pBuffer;
        <span class="keywordflow">return</span> Res;

};
<span class="preprocessor">#undef  VSNPRINTF</span>
<span class="preprocessor"></span>
string&amp;  TrimLeft (string&amp; str)
{
        <span class="keywordflow">if</span> (str.size() == 0) <span class="keywordflow">return</span> str;
        size_t i = str.find_first_not_of(<span class="stringliteral">" \t\n\r"</span>);
        str.erase (0, i);
        <span class="keywordflow">return</span> str;
};

string&amp;  TrimRight (string&amp; str)
{
        <span class="keywordflow">if</span> (str.size() == 0) <span class="keywordflow">return</span> str;
        size_t i = str.find_last_not_of(<span class="stringliteral">" \t\n\r"</span>);
        str.erase (i+1);
        <span class="keywordflow">return</span> str;
};

string&amp; Trim (string&amp; str)
{
        TrimLeft(str);
        TrimRight(str);
        <span class="keywordflow">return</span> str;
};



<span class="keyword">const</span> string open_brackets = <span class="stringliteral">"{[(&lt;"</span>;
<span class="keyword">const</span> string close_brackets = <span class="stringliteral">"}])&gt;"</span>;
<span class="keyword">const</span> string all_brackets = open_brackets+close_brackets;


<span class="keywordtype">int</span> isbracket  (BYTE x)
{
        <span class="keywordflow">if</span> (open_brackets.find(x) != string::npos)      <span class="keywordflow">return</span> 1; <span class="comment">//открывающие скобки</span>
        <span class="keywordflow">if</span> (close_brackets.find(x) != string::npos)     <span class="keywordflow">return</span> 2; <span class="comment">// закрывающие</span>
        <span class="keywordflow">return</span> 0; 
}

<span class="comment">// выдает соответствующую скобку </span>
<span class="keywordtype">int</span> dual_bracket (BYTE x)
{
        <span class="keywordtype">int</span> i = all_brackets.find(x);
        <span class="keywordflow">if</span> (i == string::npos) <span class="keywordflow">return</span> x;
        <span class="keywordtype">int</span> s = open_brackets.length();
        <span class="keywordflow">if</span> (i &gt;= s)
                <span class="keywordflow">return</span> all_brackets[i-s];
        <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> all_brackets[i+s];
}



<span class="comment">// ============     CShortString and  CShortStringHolder =========================</span>

CShortString::CShortString(vector&lt;char&gt;::const_iterator pData)
{
        m_pStringPointer = pData;
};
BYTE CShortString::GetLength()<span class="keyword"> const</span>
<span class="keyword"></span>{       
        <span class="keywordflow">return</span>  (BYTE)m_pStringPointer[0];      
}

vector&lt;char&gt;::const_iterator    CShortString::GetData()<span class="keyword"> const</span>
<span class="keyword"></span>{       
        <span class="keywordflow">return</span>  m_pStringPointer;       
}

<span class="keyword">const</span> <span class="keywordtype">char</span>*     CShortString::GetString()<span class="keyword"> const</span>
<span class="keyword"></span>{       
        <span class="keywordflow">return</span>  &amp;(m_pStringPointer[1]); 
}

<span class="keywordtype">bool</span>  CShortString::operator &lt;(<span class="keyword">const</span> <span class="keywordtype">char</span>* s)<span class="keyword"> const</span>
<span class="keyword"></span>{
        <span class="keyword">const</span> <span class="keywordtype">char</span>* q = GetString();
        <span class="keywordflow">return</span> strcmp(q, s) &lt; 0;
}





<span class="keywordtype">void</span> CShortStringHolder::ReadShortStringHolder(string filename)
{
        clear();
        file_off_t BufferSize = (int)FileSize(filename.c_str()) - <span class="keyword">sizeof</span>(size_t);

        FILE* fp = fopen(filename.c_str(), <span class="stringliteral">"rb"</span>);
        <span class="keywordflow">if</span> (!fp) <span class="keywordflow">return</span>;
        size_t Count;
        fread ((<span class="keywordtype">void</span> *)&amp;Count, 1, <span class="keyword">sizeof</span>(size_t), fp);
        <span class="keywordflow">try</span> {
                ReadVectorInner(fp, m_Buffer, BufferSize);
                fclose(fp);
                fp = 0;
        }
        <span class="keywordflow">catch</span> (...)
        {
                <span class="keywordflow">if</span> (fp) fclose(fp);
                <span class="keywordflow">throw</span>;
        }

        reserve(Count);
        <span class="keywordtype">int</span> Offset = 0;
        <span class="keywordflow">for</span> (DWORD i=0; i &lt; Count; i++)
        {
                CShortString R(m_Buffer.begin()+Offset);
                push_back(R);
                Offset +=   R.GetLength() + 2;
        };
        


};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keywordtype">bool</span> CShortStringHolder::CreateFromSequence(T begin, T end)
{
        
        m_Buffer.clear();
        size_t Count = 0;
        <span class="keywordflow">for</span> (; begin != end; begin++)
        {
                size_t length = begin-&gt;length();
                <span class="keywordflow">if</span> (length &gt; 254)
                {
                        string s = *begin + <span class="stringliteral">" - too long"</span>;
                        ErrorMessage(s.c_str(), <span class="stringliteral">"Short string convertor"</span>);
                        <span class="keywordflow">return</span> <span class="keyword">false</span>;
                };

                m_Buffer.push_back((BYTE)length);
                <span class="comment">// add with terminating null </span>
                m_Buffer.insert(m_Buffer.end(), begin-&gt;c_str(), begin-&gt;c_str() + length+1);

                Count++;
        }

        
        size_t Offset = 0;
        clear();
        <span class="keywordflow">for</span> (DWORD i=0; i &lt; Count; i++)
        {
                CShortString R(m_Buffer.begin()+Offset);
                push_back(R);
                Offset +=   R.GetLength() + 2;
        };

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}


<span class="keywordtype">bool</span> CShortStringHolder::CreateFromVector(<span class="keyword">const</span> StringVector&amp; in)
{
        <span class="keywordflow">return</span> CreateFromSequence&lt;StringVector::const_iterator&gt;(in.begin(), in.end());
}

<span class="keywordtype">bool</span> CShortStringHolder::CreateFromSet(<span class="keyword">const</span> StringSet&amp; in)
{
        <span class="keywordflow">return</span> CreateFromSequence&lt;StringSet::const_iterator&gt;(in.begin(), in.end());
}

<span class="keywordtype">bool</span> CShortStringHolder::WriteShortStringHolder(<span class="keyword">const</span> string&amp; FileName)<span class="keyword"> const</span>
<span class="keyword"></span>{
        FILE* fp = fopen (FileName.c_str(), <span class="stringliteral">"wb"</span>);
        <span class="keywordflow">if</span> (!fp)        <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <span class="keywordflow">try</span>
        {
                size_t nLength = size();
                <span class="keywordflow">if</span> (fwrite((<span class="keywordtype">void</span>*)&amp;nLength, <span class="keyword">sizeof</span>(size_t), 1,  fp) != 1)
                {
                                fclose(fp);
                                <span class="keywordflow">return</span> <span class="keyword">false</span>;
                }
                <span class="keywordflow">if</span> (!WriteVectorInner(fp, m_Buffer))
                {
                                fclose(fp);
                                <span class="keywordflow">return</span> <span class="keyword">false</span>;
                }
                <span class="keywordflow">if</span> (fclose(fp)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
        <span class="keywordflow">catch</span>(...)
        {
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}


<span class="comment">// ============     CMyTimeSpan and  CMyTimeSpanHolder =========================</span>


CMyTimeSpan::CMyTimeSpan (<span class="keywordtype">long</span> SequenceId, <span class="keywordtype">long</span> InterfaceNestId)
{
        m_TimeSpan = 0;
        m_InterfaceNestId = InterfaceNestId;
        m_SequenceId = SequenceId;
        m_InvokeCount = 0;
};

<span class="keywordtype">void</span> CMyTimeSpan::GetStrRepresentation(<span class="keyword">const</span> <span class="keywordtype">char</span>* Name, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">double</span> AllClocksCount)<span class="keyword"> const</span>
<span class="keyword"></span>{
    buffer[0] = 0;
        <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i=0; i&lt;m_InterfaceNestId; i++)
                strcat(buffer,<span class="stringliteral">"\t"</span>);
        <span class="keywordtype">char</span> t[300];
        sprintf (t, <span class="stringliteral">"%s  = %6.0f seconds;%6.0f ticks ;%i calls"</span>, 
                Name, 
                m_TimeSpan/(<span class="keywordtype">double</span>)CLOCKS_PER_SEC, 

                m_TimeSpan, 
                m_InvokeCount
                );      
        strcat (buffer, t);
        <span class="keywordflow">if</span> (AllClocksCount &gt; 0)
        {
                <span class="keywordtype">char</span> q[50];
                <span class="keywordtype">double</span> dd = (AllClocksCount== 0)? 0 : (m_TimeSpan/AllClocksCount)*100;
                sprintf (q, <span class="stringliteral">"; %6.0f %%"</span>, dd);
                strcat (buffer, q);

        };

};



CMyTimeSpanHolder::CMyTimeSpanHolder()
{
        m_SequenceId = 0;
        m_bTimeSpanHolderEnabled = <span class="keyword">true</span>;
};

<span class="keywordtype">void</span> CMyTimeSpanHolder::StartTimer(<span class="keyword">const</span> string&amp; Name, <span class="keywordtype">long</span> NestId)
{
        <span class="keywordflow">if</span> (!m_bTimeSpanHolderEnabled)  return ;
        Iterator it = m_TimeSpans.find(Name);

        <span class="keywordflow">if</span>(it == m_TimeSpans.end())
        {
                CMyTimeSpan X (m_SequenceId, NestId);

                pair&lt;Iterator, bool&gt; p = m_TimeSpans.insert(pair&lt;string, CMyTimeSpan&gt;(Name, X));

                it = p.first;
        };

        it-&gt;second.m_StartTime = clock();
        it-&gt;second.m_InvokeCount++;

        m_SequenceId++;
};

<span class="comment">//  finish timer "Name" and returns the elapsed time in ticks</span>
<span class="keywordtype">double</span> CMyTimeSpanHolder::EndTimer(<span class="keyword">const</span> string&amp; Name)
{
        <span class="keywordflow">if</span> (!m_bTimeSpanHolderEnabled)  <span class="keywordflow">return</span> 0;

        Iterator it = m_TimeSpans.find(Name);

        <span class="keywordflow">if</span>(it == m_TimeSpans.end()) 
        {
                ErrorMessage (Format(<span class="stringliteral">"Profiler error: no timer with name %s"</span>, Name.c_str()) );
                <span class="keywordflow">return</span> 0;
        };

        it-&gt;second.m_TimeSpan += (double)(clock() - it-&gt;second.m_StartTime) ;

        
        <span class="keywordflow">return</span> it-&gt;second.m_TimeSpan;
};


string CMyTimeSpanHolder::GetStrRepresentation (<span class="keywordtype">double</span> AllClocksCount)<span class="keyword"> const</span>
<span class="keyword"></span>{
        string Result;

        <span class="keywordflow">if</span> (!m_bTimeSpanHolderEnabled)  <span class="keywordflow">return</span> <span class="stringliteral">"profiler is disabled\n"</span>;

        
        map&lt;int, ConstIterator&gt;                 TimerSequence;

        <span class="keywordflow">for</span> (ConstIterator It = m_TimeSpans.begin(); It != m_TimeSpans.end();It++)
                TimerSequence[It-&gt;second.m_SequenceId] = It;

        <span class="keywordflow">for</span> (map&lt;int, ConstIterator&gt;::const_iterator It1 = TimerSequence.begin(); It1 != TimerSequence.end();It1++)
        {
                <span class="keywordtype">char</span> s[1000];
                ConstIterator It = It1-&gt;second;
                It-&gt;second.GetStrRepresentation(It-&gt;first.c_str(), s, AllClocksCount);
                Result += s;
                Result += <span class="charliteral">'\n'</span>;
        };
        <span class="keywordflow">return</span> Result;
};


<span class="keywordtype">void</span> CMyTimeSpanHolder::ClearTimers() 
{
        m_TimeSpans.clear();
        m_SequenceId = 0;
};



<span class="keywordtype">void</span> QPEncodeString(string&amp; s)
{
        string z;
        <span class="keywordflow">for</span> (size_t i=0; i&lt;s.length(); i++)
                z+= Format(<span class="stringliteral">"%2x"</span>,(BYTE)s[i]);
        s = z;
}


<span class="keywordtype">void</span> QPDecodeString(string&amp; s)
{
        string z;
        <span class="keywordtype">char</span> b[3];
        b[2] = 0;
        <span class="keywordflow">for</span> (size_t i=0; i&lt;s.length(); i+=2)
        {
                strncpy(b, s.c_str()+i,2);
                <span class="keywordtype">int</span> c;
                sscanf(b, <span class="stringliteral">"%x"</span>,&amp;c);
                z += (BYTE)c;
        };
        s = z;
}




<span class="keywordtype">bool</span> LoadFileToString(string FileName, string&amp; Result)
{
        <span class="keywordflow">if</span> ( access(FileName.c_str(), 4) != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;


        vector&lt;char&gt; V;
        ReadVector(FileName,V);
        Result = string (V.begin(), V.end());
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};

<span class="keywordtype">void</span>            SqueezeSpacesAndDeleteEoln(string&amp; s)
{
        string result;
        <span class="keywordflow">for</span> (size_t i=0; i&lt; s.length(); i++)
                <span class="keywordflow">if</span> ( isspace((BYTE) s[i]) )
                {
                        <span class="keywordflow">if</span> ( (i== 0) || !isspace((BYTE) s[i-1]))
                                result += <span class="stringliteral">" "</span>;
                }
                <span class="keywordflow">else</span>
                result += s[i];
        s = result;

};



<span class="keywordtype">bool</span> is_pseudo_graph(BYTE x)    
{
        <span class="keywordflow">return</span>  (x==134) 
                  ||(x==135) 
                  ||(x==128) 
                  ||(x==131) 
                  ||(x==136) 
                  ||(x==137) 
                  ||((x&gt;=139) &amp;&amp; (x&lt;=175))
                  ||((x&gt;=176) &amp;&amp; (x&lt;=181))
                  ||((x&gt;=186) &amp;&amp; (x&lt;=191));
};


<span class="keywordtype">bool</span> is_word_delim (BYTE x)
{
        <span class="keywordflow">return</span>  isbracket(x)
                ||      ispunct(x)
                ||      (x &lt;= 32)
                ||      is_pseudo_graph (x)
                ||      (x == cCompanyChar)
                ||      (x == cIonChar)
                ||      (x == cNumberChar)
                ||      (x == cPiChar)
                ||      (x == cEllipseChar);
}



<span class="comment">// ======================== CExcp ================</span>
CExpc::CExpc(<span class="keyword">const</span> string&amp; Cause, <span class="keywordtype">int</span> ErrorCode) 
{
    m_strCause = Cause;
        m_ErrorCode = ErrorCode;
};

CExpc::CExpc(<span class="keyword">const</span> CExpc&amp; from)
{
        *<span class="keyword">this</span> = from;
};
CExpc&amp; CExpc::operator= (<span class="keyword">const</span> CExpc&amp; from)
{
        m_strCause = from.m_strCause;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}

<span class="keywordtype">bool</span>  ReadTimeOutFromRegistry (<span class="keywordtype">bool</span> bReadFromLocalFile, <span class="keywordtype">int</span>&amp; TimeOut)
{
        string NetworkTimeOutStr;
        <span class="keywordflow">try</span> {
                <span class="keywordflow">if</span> (bReadFromLocalFile)
                        NetworkTimeOutStr  = GetRegistryStringFromLocalIniFile( <span class="stringliteral">"NetworkTimeOut"</span> );
                <span class="keywordflow">else</span>
                        NetworkTimeOutStr  = GetRegistryString( <span class="stringliteral">"NetworkTimeOut"</span> );

        }
        <span class="keywordflow">catch</span> (...) {

                ErrorMessage(<span class="stringliteral">"Cannot read NetworkTimeOut from rml.ini\n"</span>);
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        };

        TimeOut = 0;
                
        <span class="keywordflow">if</span> (!NetworkTimeOutStr.empty())
                TimeOut = atoi(NetworkTimeOutStr.c_str());

        <span class="keywordflow">if</span> (TimeOut == 0)
                TimeOut = 100;

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
};


<span class="comment">//==================================================================</span>
<span class="comment">//=========================== KOI8 &lt;==&gt; WIN ========================</span>
<span class="comment">//==================================================================</span>

BYTE kw[] = {128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
254,224,225,246,228,229,244,227,245,232,233,234,235,236,237,238,
239,255,240,241,242,243,230,226,252,251,231,248,253,249,247,250,
222,192,193,214,196,197,212,195,213,200,201,202,203,204,205,206,
207,223,208,209,210,211,198,194,220,219,199,216,221,217,215,218};


BYTE wk[] = {128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
225,226,247,231,228,229,246,250,233,234,235,236,237,238,239,240,
242,243,244,245,230,232,227,254,251,253,255,249,248,252,224,241,
193,194,215,199,196,197,214,218,201,202,203,204,205,206,207,208,
210,211,212,213,198,200,195,222,219,221,223,217,216,220,192,209};



<span class="keywordtype">char</span> wtk(<span class="keywordtype">char</span> c)
{
        
        c&amp;= 0377;
        <span class="keywordflow">if</span>(c &amp; 0200)
                c       = wk[c &amp; 0177];
        <span class="keywordflow">return</span> c;
}
<span class="keywordtype">char</span> ktw(<span class="keywordtype">char</span> c)
{
        c&amp;= 0377;
        <span class="keywordflow">if</span>(c &amp; 0200)
                c       = kw[c &amp; 0177];
        <span class="keywordflow">return</span> c;
}


<span class="keywordtype">void</span> WinToKOI8 (string&amp; s)
{
         <span class="keywordtype">int</span> count = s.length();
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; count; i++)
                 s[i] = wtk(s[i]);
};

<span class="keywordtype">void</span> KOI8ToWin (string&amp; s)
{
         <span class="keywordtype">int</span> count = s.length();
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; count; i++)
                 s[i] = ktw(s[i]);
};




<span class="keyword">static</span> <span class="keyword">const</span> DWORD arrdwCrc32Table[256] =
{
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
        0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
        0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
        0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
        0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
        0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
        0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
        0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
        0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
        0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
        0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
        0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
        0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
        0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
        0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,

        0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
        0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
        0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
        0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
        0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
        0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
        0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
        0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
        0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
        0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
        0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
        0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
        0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
        0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
        0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
        0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,

        0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
        0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
        0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
        0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
        0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
        0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
        0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
        0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
        0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
        0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
        0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
        0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
        0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
        0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
        0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
        0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,

        0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
        0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
        0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
        0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
        0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
        0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
        0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
        0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
        0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
        0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
        0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
        0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
        0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
        0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
        0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
};


DWORD StringCrc32(<span class="keyword">const</span> <span class="keywordtype">char</span>* szString)
{
        DWORD dwCrc32 = 0xFFFFFFFF;

        <span class="keywordflow">while</span>(*szString != <span class="charliteral">'\0'</span>)
        {
                dwCrc32 = ((dwCrc32) &gt;&gt; 8) ^ arrdwCrc32Table[((<span class="keywordtype">unsigned</span> char)*szString) ^ ((dwCrc32) &amp; 0x000000FF)];
                szString++;
        }

        <span class="keywordflow">return</span> ~dwCrc32;
}

<span class="comment">// ====================   StringTokenizer =======================</span>
<span class="keywordtype">bool</span> StringTokenizer::is_delim(<span class="keywordtype">char</span> ch)<span class="keyword"> const</span>
<span class="keyword"></span>{
                <span class="keywordflow">return</span> delims.find_first_of(ch) != string::npos;
}

<span class="keywordtype">void</span> StringTokenizer::initialize(<span class="keyword">const</span> <span class="keywordtype">char</span> *_text, <span class="keyword">const</span> <span class="keywordtype">char</span> *_delims)
{
        delims = _delims;
        i = -1;
        size_t leng = strlen(_text);
        text_ptr = <span class="keyword">new</span> <span class="keywordtype">char</span>[leng+2];
        text = text_ptr;
        strcpy(text, _text);
        text[leng+1] = 0;
};

StringTokenizer::StringTokenizer(<span class="keyword">const</span> <span class="keywordtype">char</span> *_text, <span class="keyword">const</span> <span class="keywordtype">char</span> *_delims)
{
        initialize(_text, _delims);
}

StringTokenizer::~StringTokenizer(){
        <span class="keyword">delete</span> []text_ptr;
}

<span class="keywordtype">void</span> StringTokenizer::reinitialize(<span class="keyword">const</span> <span class="keywordtype">char</span> *_text, <span class="keyword">const</span> <span class="keywordtype">char</span> *_delims)
{
        assert (text_ptr);
        <span class="keyword">delete</span> []text_ptr;
        initialize(_text, _delims);
}

<span class="keyword">const</span> <span class="keywordtype">char</span> * StringTokenizer::operator ()()
{
        ++i;
        <span class="comment">// skip delims</span>
        <span class="keywordflow">while</span>(*text &amp;&amp; is_delim(*text))
                text++;

        <span class="keywordflow">if</span>(*text == 0)  <span class="keywordflow">return</span> 0;

        <span class="keywordtype">char</span> *ret_val = text;

        <span class="keywordflow">while</span>(*text &amp;&amp; !is_delim(*text))
                text++;
        *text++ = 0;
        _val = ret_val;
        <span class="keywordflow">return</span> ret_val;
}
string StringTokenizer::next_token ()
{
        <span class="keyword">const</span> <span class="keywordtype">char</span>* s = operator()();
        <span class="keywordflow">if</span> (s) 
                <span class="keywordflow">return</span> s;
        <span class="keywordflow">else</span> 
                <span class="keywordflow">return</span> string();
}



<span class="comment">// redifined operators new and delete are used to find memory leaks</span>
<span class="preprocessor">#ifdef DETECT_MEMORY_LEAK</span>
<span class="preprocessor"></span><span class="preprocessor">#undef new</span>
<span class="preprocessor"></span>        <span class="keywordtype">bool</span> bStartTraceAllocation = <span class="keyword">false</span>;
        <span class="keywordtype">void</span>* operator new(size_t nSize, LPCSTR lpszFileName, <span class="keywordtype">int</span> nLine)
        {
                <span class="keywordtype">void</span> *p = <span class="keyword">new</span> <span class="keywordtype">char</span>[nSize];
                <span class="keywordflow">if</span> (bStartTraceAllocation)
                        rml_TRACE(<span class="stringliteral">"allocation %X size %i from file %s line %i\n"</span>, p, nSize, lpszFileName, nLine);
                <span class="keywordflow">return</span> p;
        };

        <span class="keywordtype">void</span>  operator delete(<span class="keywordtype">void</span>* p, LPCSTR lpszFileName, <span class="keywordtype">int</span> nLine)
        {
                <span class="keyword">delete</span> p;
        };
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>


string ConvertASCIIToHtmlSymbols(<span class="keyword">const</span> string&amp; txt)
{
        string out;
        <span class="keywordtype">char</span> asciiCode[2];
        asciiCode[1] = 0;
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;txt.length(); i++ )
        {
                asciiCode[0] = txt[i];
                <span class="keywordflow">switch</span> (asciiCode[0])
                {
                        <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
                                out += <span class="stringliteral">" "</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
                                out += <span class="stringliteral">"    "</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
                                out += <span class="stringliteral">"&amp;quot;"</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> <span class="charliteral">'&amp;'</span>:
                                out += <span class="stringliteral">"&amp;amp;"</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> <span class="charliteral">'&lt;'</span>:
                                out += <span class="stringliteral">"&amp;lt;"</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> <span class="charliteral">'&gt;'</span>:
                                out += <span class="stringliteral">"&amp;gt;"</span>;
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">default</span>:
                                out += asciiCode;
                }
        }
        <span class="keywordflow">return</span> out;
}


<span class="keywordtype">bool</span>  MakeDir(<span class="keyword">const</span> string&amp; txt)
{
<span class="preprocessor">        #ifdef WIN32</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span> _mkdir(txt.c_str()) != -1;
<span class="preprocessor">        #else</span>
<span class="preprocessor"></span>                <span class="keywordflow">return</span> mkdir(txt.c_str(), 0777) != -1;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>};





</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Tue Feb 7 15:38:48 2006 for Synan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
