3.11.4 Остановка и возобновление работы 


Есть другой способ перевести работу в фоновый режим. Вы можете начать работу нормально (в режиме переднего плана), остановить работу и продолжить в фоновом режиме.

 


Сначала начнем работу "нормально":

 

    /home/larry# yes > /dev/null




Поскольку опять работа выполняется на переднем плане, вы не получите обратно на экран подсказку shell.

 


Теперь, вместо того, чтобы прерывать работу с помощью ctrl-C, мы остановим работу. Приостановка работы не убивает ее. Чтобы осуществить приостановку работы, надо нажать соответствующие клавиши, обычно это ctrl-Z.

 

    /home/larry# yes > /dev/null
    [ctrl-Z]
    [1]+  Stopped                 yes >/dev/null
    /home/larry#




Пока работа остановлена, она просто не выполняется. На нее не тратится время процессора. Но вы всегда можете возобновить работу, и она продолжится как ни в чем не бывало.

 


Для возобновления работы в режиме переднего плана используйте команду fg (``foreground'' - передний план).

 

    /home/larry# fg
    yes >/dev/null




Shell снова выдаст на экран имя команды, чтобы вы могли проконтролировать, какую работу вы активизировали в режиме переднего плана. Вновь остановите работу с помощью ctrl-Z. В этот раз используйте команду bg (``background'' - задний план, фоновый режим), чтобы перевести работу в фоновый режим. Эффект будет аналогичен тому, как если бы вы набрали после команды ``&''.

 

    /home/larry# bg
    [1]+ yes >/dev/null &
    /home/larry#




И мы получили назад подсказку. Команда jobs сообщит, что команда yes действительно выполняется, и мы можем снова ее убить с помощью команды kill, как мы это уже делали.

 


Как теперь остановить работу? Использование ctrl-Z не поможет, поскольку работа находится в фоновом режиме. Ответ -
переместить работу на передний план, а затем остановить. Вы можете использовать fg как для остановленных работ, так и для работ, находящихся в фоне.

 


Существует большая разница между фоновой работой и остановленной. Остановленная работа не выполняется и не использует время процессора, да и никакой работы, честно говоря, в этот момент не делает (но занимает память, хотя по воле своппинга может оказаться на диске). Работа в фоновом режиме и выполняется, и занимает память. Она может даже выводить что-то на экран, хотя это может раздражать вас, когда вы работаете над чем-то другим. Например, если вы использовали команду:

 

    /home/larry# yes &




без перенаправления stdout в /dev/null, поток "y" будет выводиться на экран без возможности прервать это (вы не сможете использовать ctrl-C для прерывания работ фонового режима). Чтобы остановить эту бесконечную выдачу, вам следует использовать команду fg для перевода работы в режим переднего плана, а затем использовать ctrl-C, чтобы ее убить.

 


Еще одно замечание. Команды fg и bg обычно переводят на передний план или в фоновый режим работы, которые были остановлены последними (что определяется символом ``+'' после номера работы, это когда вы используете команду jobs). Если вы выполняете много работ одновременно, вы можете перевести на передний план или, наоборот, в фоновый режим конкретную работу заданием идентификатора работы в качестве аргумента команд fg или bg, как в

 

    /home/larry# fg %2


(перевод на передний план работы номер 2) или

 

    /home/larry# bg %3


(перевод в фон работы номер 3).

 


Для этих команд нельзя использовать идентификаторы процессов. Кроме того, использование только номеров работ, как в

 

    /home/larry# %2

     эквивалентно

    /home/larry# fg %2




Помните, что управление работами, это свойство shell. Команды fg, bg и jobs - внутренние команды shell. Если по какой-то причине вы используете shell, который не поддерживает управление работами, там вы не найдете этих команд.

 


В дополнение к этому, есть некоторые аспекты управления работами, которые различаются в Bash и Tcsh. Некоторые оболочки не имеют управления работами, хотя большинство оболочек Linux имеют такую возможность.

 




